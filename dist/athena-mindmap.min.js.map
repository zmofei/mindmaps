{"version":3,"sources":["webpack://AthenaMindmap/webpack/bootstrap","webpack://AthenaMindmap/webpack/runtime/make namespace object","webpack://AthenaMindmap/./src/graph/canvas/cavnas-node-types.ts","webpack://AthenaMindmap/./src/graph/canvas/nodeStyle.ts","webpack://AthenaMindmap/./src/graph/canvas/editor.ts","webpack://AthenaMindmap/./src/graph/canvas/nodes.ts","webpack://AthenaMindmap/./src/graph/canvas/creater.ts","webpack://AthenaMindmap/./src/dev/athena-dev.ts","webpack://AthenaMindmap/./src/athena-mindmap.ts"],"names":["__webpack_require__","exports","Symbol","toStringTag","Object","defineProperty","value","NodeType","NodeState","NodePadding","this","chagneEvents","box","document","createElement","style","position","zIndex","dom","innerHTML","contentEditable","font","left","top","whiteSpace","transform","appendChild","body","addEventListener","e","key","returnValue","console","log","innerText","replace","changeNode","context","show","x","y","width","height","scale","node","lastPosition","display","transformOrigin","range","createRange","sel","window","getSelection","setStart","collapse","removeAllRanges","addRange","hide","change","fn","push","editor","Editor","ctx","config","fatherId","id","Date","toString","Math","random","type","Node","_state","Default","childrenSumHeight","outerHeight","computerSize","txt","measureText","_context","contextWidth","contextHeight","fontBoundingBoxAscent","fontBoundingBoxDescent","boxWidth","boxHeight","NodeMargin","outerWidth","bindTree","shakeTree","graph","draw","Edit","editoringNode","Root","item","NodeItem","rootid","tree","nodesRef","father","addNode","fatherid","fatherItem","children","increateHeight","length","loopItem","loopItemId","stacks","info","fatherY","fatherX","items","keys","map","boardList","textList","linkList","stackItem","shift","listHgihtTrim","forEach","index","nextSilbingStartY","onlyChildren","itemY","state","drawBoard","list","selecteNode","save","listByType","listItem","selected","beginPath","board","offset","translate","lineWidth","moveTo","lineTo","arc","PI","closePath","stroke","fillStyle","fill","lineCap","restore","drawNode","fillRect","debug","strokeStyle","strokeRect","fillText","toFixed","drawText","textAlign","textBaseline","drawLink","startX","startY","endX","endY","deltaY","abs","middleX","endLowerThanStart","quadraticCurveTo","bezierCurveTo","updateEditor","dpr","devicePixelRatio","getTransform","ctxScale","ctxOffsetX","ctxOffsetY","nodeX","nodeY","screenOrignX","screenOrginY","offsetX","offsetY","size","events","canvas","getContext","adjustCanvs","bindEvent","testNode","NodeTree","tid","nodeTrees","moving","mousedownX","mousedownY","lastX","lastY","moveDelteX","moveDelteY","scaleRatio","stack","roodId","pop","xInBoundary","max","yInBoundary","nodeChildren","XinBox","YOffset","YinBox","cursor","hover","preventDefault","newTransform","a","f","scaleDelta","pow","setTransform","editItem","clearRect","xCount","round","i","yCount","styleInfo","getComputedStyle","parseFloat","coreCanvas","CoreCanvas","container","getElementById"],"mappings":"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","file":"athena-mindmap.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export enum NodeType {\n    Root = 'ROOT',\n    Node = 'NODE'\n}\n\nexport enum NodeState {\n    Edit = 'Edit',\n    Default = 'Default'\n}","import { NodeType } from './cavnas-node-types'\n\nconst NodeMargin = 10\nconst NodePadding = 10\nconst ListPadding = 100\n\n\nfunction drawNode(type: NodeType, ctx: CanvasRenderingContext2D, list: any) {\n    ctx.save()\n    if (type === NodeType.Root) {\n        ctx.beginPath()\n        list.forEach((board: any) => {\n            const [item, offset] = board\n            const { context, boxHeight, boxWidth, outerHeight } = item\n            let { x, y } = offset\n            y = y + item.boxHeight / 2\n            ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n            const radius = 6;\n            ctx.lineWidth = 4\n            ctx.moveTo(-NodePadding, 0)\n            ctx.lineTo(-NodePadding, -boxHeight / 2 + radius)\n            ctx.arc(-NodePadding + radius, -boxHeight / 2 + radius, radius, Math.PI, Math.PI * (3 / 2))\n            ctx.lineTo(boxWidth - NodePadding - radius, -boxHeight / 2)\n            ctx.arc(boxWidth - NodePadding - radius, -boxHeight / 2 + radius, radius, Math.PI * (3 / 2), 2 * Math.PI)\n            ctx.lineTo(boxWidth - NodePadding, boxHeight / 2 - radius)\n            ctx.arc(boxWidth - NodePadding - radius, boxHeight / 2 - radius, radius, 2 * Math.PI, Math.PI * (1 / 2))\n            ctx.lineTo(-NodePadding + radius, boxHeight / 2)\n            ctx.arc(-NodePadding + radius, boxHeight / 2 - radius, radius, Math.PI / 2, Math.PI)\n            ctx.lineTo(-NodePadding, 0)\n            ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n        })\n        ctx.closePath()\n        ctx.stroke()\n        ctx.fillStyle = 'white'\n        ctx.fill()\n    } else if (type === NodeType.Node) {\n        ctx.beginPath()\n        list.forEach((board: any) => {\n            const [item, offset] = board\n            const { context, boxHeight, boxWidth, outerHeight } = item\n            const { x, y } = offset\n            ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n            ctx.lineCap = 'round';\n            ctx.lineWidth = 2\n            ctx.moveTo(-NodePadding, boxHeight / 2)\n            ctx.lineTo(item.boxWidth - NodePadding, boxHeight / 2)\n            ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n        })\n        ctx.closePath()\n        ctx.stroke()\n    }\n    ctx.restore()\n}\n\n\n\nexport { NodeType, NodeMargin, NodePadding, ListPadding, drawNode }","import { NodeItem } from \"./nodes\"\n\nexport class Editor {\n    box: HTMLElement\n    dom: HTMLElement\n    chagneEvents: Function[]\n    changeNode: NodeItem\n    lastPosition: { x: number, y: number, scale: number }\n    constructor() {\n        this.chagneEvents = []\n        const box = this.box = document.createElement('div')\n\n\n        box.style.position = 'absolute'\n        box.style.zIndex = '999'\n        this.dom = document.createElement('div')\n        this.dom.innerHTML = 'Hello'\n        this.dom.contentEditable = 'true'\n        this.dom.style.font = \"14px Arial\"\n        this.dom.style.position = 'absolute'\n        this.dom.style.left = '0'\n        this.dom.style.top = '0'\n        this.dom.style.whiteSpace = 'nowrap'\n\n        this.dom.style.transform = \"translate(0, -100%)\"\n        box.appendChild(this.dom)\n        document.body.style.position = 'relative'\n        document.body.appendChild(box)\n        // bind Change event\n        this.dom.addEventListener('keypress', (e) => {\n            if (e.key === 'Enter') {\n                e.returnValue = false\n            }\n        })\n        this.dom.addEventListener('input', (e) => {\n            console.log(this.dom.innerText.replace(/\\n/gi, ''))\n            this.changeNode.context = this.dom.innerText.replace(/\\n/gi, '')\n        })\n\n    }\n\n    show(x: number, y: number, width: number, height: number, scale: number, node: NodeItem) {\n        const lastPosition = this.lastPosition || { x: 0, y: 0, scale: 0 }\n\n        this.changeNode = node\n        this.box.style.display = 'inline-block'\n        this.dom.style.transformOrigin = `bottom left`\n        this.box.style.transform = `translate(${x}px, ${y}px) scale(${scale / 2})`\n\n        if (!(x === lastPosition.x && y === lastPosition.y && scale === lastPosition.scale)) {\n            this.dom.innerText = node.context\n            var range = document.createRange()\n            var sel = window.getSelection()\n            range.setStart(this.dom, 0)\n            range.collapse(true)\n\n            sel.removeAllRanges()\n            sel.addRange(range)\n\n        }\n        this.lastPosition = { x, y, scale }\n    }\n\n    hide() {\n        this.box.style.display = 'none'\n    }\n\n    change(fn: Function) {\n        this.chagneEvents.push(fn)\n    }\n\n}\n\n","import { NodeType, drawNode, NodeMargin, NodePadding, ListPadding, } from './nodeStyle'\nimport { NodeState } from './cavnas-node-types'\nimport { Editor } from './editor'\n\nconst editor = new Editor()\n\ninterface config {\n    context: string,\n    fatherId?: string,\n    type?: NodeType\n}\n\n\ntype renderListWithItem = [NodeItem, { x: number, y: number }][];\ntype renderListwithCoordinate = [number, number, number, number][]\n\n\nclass NodeItem {\n    ctx: CanvasRenderingContext2D\n    id: string\n    contextWidth: number\n    contextHeight: number\n    x: number\n    y: number\n    boxWidth: number\n    boxHeight: number\n    outerHeight: number\n    outerWidth: number\n    childrenSumHeight: number\n    children: NodeItem[]\n\n    selected: boolean\n    fatherId: string\n    father: NodeItem\n    type: NodeType\n    _state: NodeState\n    _groupindex: number\n    _context: string\n    bindTree: NodeTree\n    constructor(ctx: CanvasRenderingContext2D, config: config = { context: '', fatherId: null }) {\n        const id = (+new Date()).toString(32) + (Math.random().toString(32))\n        this.id = id\n        this.ctx = ctx\n        this.x = 0\n        this.y = 0\n        this.type = config.type ?? NodeType.Node\n        this._state = NodeState.Default\n\n        this.context = config.context\n        this.fatherId = config.fatherId || null\n\n        // \n        this.childrenSumHeight = this.outerHeight\n    }\n\n    computerSize() {\n        const ctx = this.ctx\n\n        ctx.font = \"14px Arial\";\n        const txt = this.ctx.measureText(this._context);\n        this.contextWidth = txt.width;\n        // @ts-ignore\n        this.contextHeight = txt.fontBoundingBoxAscent + txt.fontBoundingBoxDescent;\n        this.boxWidth = this.contextWidth + NodePadding * 2;\n        this.boxHeight = this.contextHeight + NodePadding * 2;\n        this.outerHeight = this.boxHeight + NodeMargin * 2\n        this.outerWidth = this.boxWidth + NodeMargin * 2\n    }\n\n    get context(): string {\n        return this._context\n    }\n    set context(value) {\n        this._context = value\n        this.computerSize()\n        // this.tree\n        // setTimeout(() => {\n        this.bindTree?.shakeTree()\n        this.bindTree?.graph?.draw()\n        // }, 1000)\n\n    }\n\n    get state(): NodeState {\n        return this._state\n    }\n\n    set state(value) {\n        if (value === NodeState.Edit) {\n            this.bindTree.editoringNode = this\n        } else {\n            this.bindTree.editoringNode = null\n        }\n        this._state = value\n    }\n}\n\n\nclass NodeTree {\n    config: {\n        x: number,\n        y: number,\n        context?: string,\n        contextWidth?: number,\n        contextHeight?: number,\n    }\n\n    ctx: CanvasRenderingContext2D\n    tree: { [key: string]: NodeItem }\n    rootid: string\n    nodesRef: { [key: string]: NodeItem }\n    boardList: renderListWithItem\n    textList: renderListWithItem\n    linkList: renderListwithCoordinate\n    editoringNode: NodeItem\n    graph: any\n\n    constructor(graph: any, config = { x: 0, y: 0, context: '', type: NodeType.Root }) {\n        this.graph = graph\n        const ctx = this.ctx = graph.ctx\n        const item = new NodeItem(ctx, { ...config, type: NodeType.Root });\n        this.rootid = item.id\n        this.tree = {}\n        this.tree[this.rootid] = item\n        this.nodesRef = this.nodesRef || {}\n        this.nodesRef[this.rootid] = item\n        // bind father\n        if (item.fatherId && this.tree[item.fatherId]) {\n            item.father = this.tree[item.fatherId]\n        }\n        item.bindTree = this\n\n        editor.change((value: string) => {\n            this.shakeTree()\n            this.draw()\n        })\n    }\n\n    addNode(config = { y: 0, context: '' }, fatherid?: string) {\n        const fatherId = fatherid || this.rootid;\n        const fatherItem = this.nodesRef[fatherId];\n        const item = new NodeItem(this.ctx, {\n            ...config,\n            fatherId: fatherId\n        });\n\n        // add item to fater\n        fatherItem.children = fatherItem.children || []\n        fatherItem.children.push(item)\n        this.nodesRef[item.id] = item\n\n        // bind father\n        if (item.fatherId && this.tree[item.fatherId]) {\n            item.father = fatherItem\n        }\n        item.bindTree = this\n\n        // Re-computer position\n        // Height: update the height of all the affected nodes from parent to root\n        const onlyChildren = (fatherItem.children || []).length <= 1\n        const increateHeight = onlyChildren ? 0 : item.outerHeight\n        let loopItem = item;\n        while (loopItem) {\n            const loopItemId = loopItem.fatherId\n            const fatherItem = this.nodesRef[loopItemId];\n            if (!loopItemId || !fatherItem) {\n                loopItem = null\n            } else {\n                fatherItem.childrenSumHeight += increateHeight\n                loopItem = fatherItem\n            }\n        }\n\n        // x,y\n        // A Node added may cause all the tree's layout change\n        // we need to restracture all the x,y for the tree.\n        this.shakeTree()\n\n        // \n        this.draw()\n\n        // \n        return item.id\n    }\n\n    // Reset all the node's position\n    shakeTree() {\n        interface drawInfo {\n            x: number\n            fatherY: number,\n            fatherX: number,\n            father?: NodeItem\n        }\n\n        const root = Object.keys(this.tree).map(id => this.nodesRef[id]);\n        const stacks: { info: drawInfo, items: NodeItem[] }[] = [{ info: { x: 0, fatherY: 0, fatherX: 0, }, items: root }];\n\n        const boardList: [NodeItem, { x: number, y: number }][] = [];\n        const textList: [NodeItem, { x: number, y: number }][] = [];\n        const linkList: [number, number, number, number][] = [];\n\n        let editingNode = null\n\n        while (stacks.length > 0) {\n            const stackItem = stacks.shift();\n\n            const info = stackItem.info;\n            const items = stackItem.items;\n\n            let listHgihtTrim = 0;\n            items.forEach((item, index) => {\n                listHgihtTrim += item.childrenSumHeight\n            })\n\n            const listStartY = info.fatherY - listHgihtTrim / 2\n\n            let nextSilbingStartY = listStartY\n            const onlyChildren = items.length === 1\n            items.forEach((item, index) => {\n                let itemY;\n                if (onlyChildren) {\n                    itemY = info.fatherY\n                } else {\n                    itemY = nextSilbingStartY + item.childrenSumHeight / 2\n                    nextSilbingStartY += item.childrenSumHeight\n                }\n                item.x = info.x\n                item.y = itemY\n\n                boardList.push([item, { x: info.x, y: itemY }])\n\n                textList.push([item, { x: info.x, y: itemY }])\n\n\n                if (info.father) {\n                    linkList.push([\n                        info.fatherX + info.father.boxWidth,\n                        info.fatherY,\n                        info.x,\n                        itemY\n                    ])\n                }\n\n                // \n                if (item.state === NodeState.Edit) {\n                    editingNode = item\n                }\n\n                const children = item.children;\n                if (children) {\n                    stacks.push({ info: { x: info.x + item.boxWidth + ListPadding, fatherY: itemY, fatherX: info.x, father: item }, items: children })\n                }\n            })\n        }\n\n        this.boardList = boardList;\n        this.textList = textList;\n        this.linkList = linkList;\n    }\n\n    // draw board box\n    drawBoard() {\n        const list = this.boardList\n        const ctx = this.ctx\n        const selecteNode: NodeItem[] = []\n        ctx.save()\n        const listByType: {\n            [key: string]: {\n                type: NodeType,\n                list: renderListwithCoordinate | renderListWithItem\n            }\n        } = {}\n\n        list.forEach(listItem => {\n            const [NodeItem] = listItem\n            if (NodeItem.selected) {\n                selecteNode.push(NodeItem)\n            }\n            listByType[NodeItem.type] = listByType[NodeItem.type] || {\n                type: NodeItem.type,\n                list: []\n            }\n            // @ts-ignore\n            listByType[NodeItem.type].list.push(listItem)\n        })\n\n        Object.keys(listByType).forEach(type => {\n            const list = listByType[type];\n            drawNode(list.type, this.ctx, list.list);\n        })\n        ctx.restore()\n\n        // draw selected\n        ctx.save()\n        selecteNode?.forEach(node => {\n            this.ctx.fillStyle = 'rgba(0,102,255,0.2)'\n            if (node.type === NodeType.Root) {\n                this.ctx.fillRect(node.x, node.y - node.boxHeight / 2, node.boxWidth, node.boxHeight)\n            } else {\n                this.ctx.fillRect(node.x, node.y - node.boxHeight, node.boxWidth, node.boxHeight)\n            }\n        })\n        ctx.restore()\n\n        // for debug\n        if (window.debug) {\n            list.forEach(board => {\n                const [item, offset] = board\n                const { x, y } = offset\n\n\n\n                // origin\n                ctx.save()\n                ctx.fillStyle = 'red'\n                ctx.translate(x, y)\n                ctx.fillRect(-2, -2, 4, 4)\n                ctx.restore()\n                // group\n                ctx.save()\n                ctx.fillStyle = 'red'\n                ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n                this.ctx.strokeStyle = 'red'\n                ctx.strokeRect(-NodePadding, -item.childrenSumHeight / 2, item.boxWidth, item.childrenSumHeight)\n                ctx.restore()\n\n                // context\n                ctx.save()\n                ctx.translate(x, y)\n                ctx.translate(NodePadding, -item.boxHeight / 2)\n                ctx.strokeRect(0, -item.contextHeight / 2, item.contextWidth, item.contextHeight)\n                ctx.restore()\n                // outer\n                ctx.save()\n                ctx.strokeStyle = 'grey'\n                ctx.translate(x, y)\n                ctx.translate(-NodePadding, -item.boxHeight - NodeMargin)\n                ctx.strokeRect(0, 0, item.outerWidth, item.outerHeight)\n                ctx.restore()\n                // box\n                ctx.save()\n                ctx.strokeStyle = 'yellow'\n                ctx.translate(x, y)\n                ctx.translate(0, -item.boxHeight)\n                ctx.strokeRect(0, 0, item.boxWidth, item.boxHeight)\n                ctx.restore()\n\n\n                // Tips text\n                ctx.save()\n                ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n                this.ctx.fillStyle = 'red'\n                ctx.font = \"10px Arial\";\n                ctx.fillText((item.childrenSumHeight).toFixed(2).toString(), item.boxWidth, NodePadding * 2 - item.boxHeight)\n                ctx.fillText((item.outerHeight).toFixed(2).toString(), item.boxWidth, NodePadding * 2 - item.boxHeight + 10)\n                ctx.fillText(`${(item.x).toFixed(0).toString()},${(item.y || 0).toFixed(0).toString()} `, item.boxWidth, NodePadding * 2 - item.boxHeight + 20)\n                ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n                ctx.restore()\n\n            })\n\n        }\n    }\n\n    drawText() {\n        const list = this.textList\n        const ctx = this.ctx\n        ctx.save()\n        ctx.textAlign = 'left'\n        ctx.textBaseline = 'middle'\n\n        list.forEach(board => {\n            const [item, offset] = board\n            if (item === this.editoringNode) return false\n            let { x, y } = offset\n            if (item.type === NodeType.Root) {\n                y = y + item.boxHeight / 2\n            }\n            ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n            const { context, boxHeight, boxWidth, outerHeight } = item\n            ctx.font = \"14px Arial\";\n            ctx.fillText(context, 0, 0)\n            ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n        })\n        ctx.restore()\n    }\n\n    drawLink() {\n        const list = this.linkList\n        const ctx = this.ctx\n        ctx.save()\n\n        ctx.beginPath()\n        list.forEach(board => {\n\n            //                                    (endX, endY)\n            //                              ---------- B\n            //                             |\n            //          A --------(middleX, startY)\n            //  (startX, startY)           |\n            //                              ---------- C\n            //                                    (endX, endY)\n\n            const [startX, startY, endX, endY] = board;\n            const deltaY = Math.abs(endY - startY);\n            const radius = 6;\n            const middleX = (startX + endX) / 2;\n            const endLowerThanStart = endY < startY;\n\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(middleX - radius, startY);\n            // inflection\n            if (deltaY / 2 >= radius) {\n                ctx.quadraticCurveTo(middleX, startY, middleX, startY + (endLowerThanStart ? -radius : radius))\n                ctx.lineTo(middleX, endY + (endLowerThanStart ? radius : -radius));\n                ctx.quadraticCurveTo(middleX, endY, middleX + radius, endY)\n            } else {\n                ctx.bezierCurveTo(middleX, startY, middleX, endY, middleX + radius, endY)\n            }\n            // \n            ctx.lineTo(endX, endY)\n        })\n        ctx.stroke()\n        ctx.closePath()\n    }\n\n    updateEditor() {\n        const node = this.editoringNode;\n        const dpr = window.devicePixelRatio || 1\n        if (!node) {\n            editor.hide()\n            return;\n        }\n        // TODO: Show the editor \n        const { a: ctxScale, e: ctxOffsetX, f: ctxOffsetY } = this.ctx.getTransform()\n\n        const { x: nodeX, y: nodeY, contextWidth, contextHeight } = node\n\n        const [screenOrignX, screenOrginY] = [(ctxOffsetX + nodeX * ctxScale) / dpr, (ctxOffsetY + nodeY * ctxScale) / dpr]\n\n        let offsetX = 0;\n        let offsetY = 0;\n        if (node.type === NodeType.Node) {\n            offsetX = NodePadding * (ctxScale / dpr)\n            offsetY -= NodePadding * (ctxScale / dpr)\n        }\n\n\n        editor.show(screenOrignX + offsetX, screenOrginY + offsetY, contextWidth, contextHeight, ctxScale, node)\n\n    }\n\n    draw() {\n        // draw components step by step\n        this.drawBoard()\n        this.drawText()\n        this.drawLink()\n        this.updateEditor()\n    }\n}\n\n\nexport { NodeItem, NodeTree }","// This file is to create the init Canvas document and set up the resolution and other stuffs.\n// @ts-nocheck\n\nimport { NodeItem, NodeTree } from './nodes'\nimport { NodeType, NodeState } from './cavnas-node-types'\n\ninterface size {\n    width: number,\n    height: number\n}\n\nclass CoreCanvas {\n    canvas: HTMLCanvasElement\n    ctx: CanvasRenderingContext2D\n    offset: {\n        x: number,\n        y: number,\n    }\n    events: any\n    scale: number\n    nodeTrees: NodeItem[]\n    hover: NodeItem\n    selected: NodeItem\n    editItem: NodeItem\n    size: size\n    dpr: number\n\n    constructor(size: size) {\n        this.dpr = window.devicePixelRatio || 1\n        this.scale = this.dpr;\n        this.size = size\n        this.offset = { x: size.width / 2 * this.scale, y: size.height / 2 * this.scale }\n        this.events = {}\n\n        const canvas = this.canvas = document.createElement('canvas')\n        this.ctx = canvas.getContext('2d')\n        window.ctx = this.ctx\n\n        this.adjustCanvs(canvas, size);\n        this.bindEvent()\n\n        // TEST\n        // addNode\n        const testNode = window.testNode = new NodeTree(this, {\n            x: 0,\n            y: 0,\n            context: 'Hello'\n        })\n\n        let tid = 0;\n        tid = testNode.addNode({\n            context: 'Robin Ma'\n        })\n\n\n        tid = testNode.addNode({\n            context: 'CKY'\n        })\n        testNode.addNode({\n            context: 'Name: kaiyue'\n        }, tid)\n        tid = testNode.addNode({\n            context: 'Mofei Zhu'\n        })\n\n        testNode.addNode({\n            context: 'Name: Mofei'\n        }, tid)\n        testNode.addNode({\n            context: 'Sex: Fame'\n        }, tid)\n\n        tid = testNode.addNode({\n            context: 'Age: 18'\n        }, tid)\n\n\n        tid = testNode.addNode({\n            context: 'Mll'\n        })\n\n        const selected = testNode.nodesRef[tid];\n        // selected.state = NodeState.Edit\n        this.nodeTrees = [testNode]\n\n        tid = testNode.addNode({\n            context: 'Mll'\n        })\n    }\n\n    adjustCanvs(canvas: HTMLCanvasElement, size: size) {\n        // Get the device pixel ratio, falling back to 1.\n\n        // Give the canvas pixel dimensions of their CSS\n        // size * the device pixel ratio.\n        canvas.style.width = `${size.width}px`;\n        canvas.style.height = `${size.height}px`;\n        canvas.width = size.width * this.dpr;\n        canvas.height = size.height * this.dpr;\n        this.ctx.translate(this.offset.x, this.offset.y)\n        this.ctx.scale(this.dpr, this.dpr)\n    }\n\n    // The events Config the canvas by translate and scale, so that NodeItems don't need to care about the translate and scale\n    bindEvent() {\n        const canvas = this.canvas;\n        let moving = 'DONE';\n        let mousedownX = null;\n        let mousedownY = null;\n        let lastX = null;\n        let lastY = null;\n\n        canvas.addEventListener('mousedown', (e) => {\n            moving = 'PREPARE';\n            lastX = mousedownX = e.offsetX\n            lastY = mousedownY = e.offsetY\n        });\n\n        canvas.addEventListener('mousemove', (e) => {\n            if (moving === 'PREPARE' || moving === 'MOVING') {\n                // Moving modle\n                // In moving modle we translate the canvas, \n                //   so that in the node tree draw step, \n                //   the nodes don't need to consider the canvas translate.\n                const { dpr, scale, offset } = this\n                const moveDelteX = e.offsetX - lastX;\n                const moveDelteY = e.offsetY - lastY;\n                const scaleRatio = (scale / dpr);\n                lastY = e.offsetY\n                lastX = e.offsetX\n                moving = 'MOVING'\n\n                this.ctx.translate(moveDelteX / scaleRatio, moveDelteY / scaleRatio)\n\n                this.draw()\n            } else {\n                // Free move modle\n                // In free modle, we calculate the mouse's relation with the nodes,\n                //   and save the hovered node to this.hover\n                const onCanvasX = (e.offsetX * this.dpr - this.offset.x) / this.scale\n                const onCanvasY = (e.offsetY * this.dpr - this.offset.y) / this.scale\n\n                let matchedNode = null;\n                // Loop the tree's position\n                this.nodeTrees.forEach(({ tree }) => {\n                    const stack = [Object.keys(tree).map(roodId => tree[roodId])];\n                    while (stack.length >= 1) {\n                        const nodes = stack.pop();\n\n                        for (let node of nodes) {\n                            const nodeXRange = Math.max(Math.abs(node.x), 0)\n\n                            const xInBoundary = nodeXRange < Math.abs(onCanvasX);\n                            const yInBoundary = Math.abs(node.y || 0) < (Math.abs(onCanvasY) + node.outerHeight);\n                            const nodeChildren = node.children\n                            if (xInBoundary && yInBoundary) {\n                                // math Node\n                                //  -----------------         -----------------\n                                // |                 |       |                 |\n                                // .(x,y) ROOOT      |       |    Others       |\n                                // |                 |       |                 |\n                                //  -----------------        .(x,y)------------\n                                // If the node type is root the origin is in the left-middle\n                                // Other whise the origin is in the left-bottom\n                                const XinBox = onCanvasX >= node.x && onCanvasX <= node.x + node.boxWidth\n                                let YOffset = node.type === NodeType.Root ? node.boxHeight / 2 : 0\n                                const YinBox = onCanvasY >= (node.y - node.boxHeight + YOffset) && onCanvasY <= (node.y + YOffset)\n                                if (XinBox && YinBox) {\n                                    matchedNode = node\n                                    stack.length = 0\n                                    break\n                                }\n\n                                if (nodeChildren) {\n                                    stack.push(nodeChildren)\n                                }\n                            }\n                        }\n                    }\n                })\n\n                if (matchedNode) {\n                    this.canvas.style.cursor = 'pointer'\n                } else {\n                    this.canvas.style.cursor = 'default'\n                }\n\n                this.hover = matchedNode\n            }\n        });\n\n        canvas.addEventListener('mouseup', (e) => {\n            e.preventDefault()\n            moving = 'DONE'\n            lastX = lastY = null\n            const newTransform = this.ctx.getTransform()\n            this.scale = newTransform.a\n            this.offset = {\n                x: newTransform.e,\n                y: newTransform.f\n            }\n        });\n\n        canvas.addEventListener('wheel', (e) => {\n            const { dpr, scale, offset } = this\n            e.preventDefault();\n\n            const scaleDelta = Math.pow(1.01, -e.deltaY);\n            const scaleRatio = (scale / dpr);\n\n            ctx.setTransform(scale, 0, 0, scale, offset.x, offset.y)\n            this.ctx.translate(-offset.x / scale + e.offsetX / scaleRatio, -offset.y / scale + e.offsetY / scaleRatio)\n            this.ctx.scale(scaleDelta, scaleDelta)\n            this.ctx.translate(-(-offset.x / scale + e.offsetX / scaleRatio), -(-offset.y / scale + e.offsetY / scaleRatio))\n\n            const newTransform = this.ctx.getTransform()\n            this.scale = newTransform.a\n            this.offset = {\n                x: newTransform.e,\n                y: newTransform.f\n            }\n\n            this.draw()\n        });\n\n        canvas.addEventListener('click', (e) => {\n\n            //  selected.state = NodeState.Edit\n            if (this.hover && this.selected === this.hover) {\n                this.hover.state = NodeState.Edit\n                this.editItem = this.hover\n            } else if (this.hover !== this.editItem) {\n                this.editItem?.state = NodeState.Default\n                this.editItem = null\n            }\n\n            // pick up hovered node\n            this.selected?.selected = false\n            if (Math.abs(e.offsetX - mousedownX) > 5 || Math.abs(e.offsetY - mousedownY) > 5) return false;\n            this.selected = this.hover;\n            this.selected?.selected = true;\n\n            this.draw();\n        })\n    }\n\n    // Draw Nodetree\n    // 1. Clean the canvas\n    // 2. Call the draw function from the Node tree\n    draw() {\n        const ctx = this.ctx;\n        // Reset the canvas and clean it\n        ctx.save()\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n        ctx.fillStyle = '#f3f3f4'\n        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n        ctx.restore();\n\n\n        // \n        if (window.debug) {\n            // origin \n            this.ctx.save()\n            this.ctx.beginPath()\n            this.ctx.strokeStyle = 'red'\n            this.ctx.lineWidth = 2\n            this.ctx.moveTo(0, -5)\n            this.ctx.lineTo(0, 5)\n            this.ctx.moveTo(-5, 0)\n            this.ctx.lineTo(5, 0)\n            this.ctx.stroke()\n            this.ctx.closePath()\n\n            // gird\n            this.ctx.beginPath()\n            this.ctx.strokeStyle = '#ddd'\n            const xCount = Math.round(this.size.width / 10)\n            for (let i = -xCount; i < xCount; i += 1) {\n                this.ctx.moveTo(i * -10, -this.size.height)\n                this.ctx.lineTo(i * -10, this.size.height)\n            }\n            const yCount = Math.round(this.size.height / 10)\n            for (let i = -yCount; i < yCount; i += 1) {\n                this.ctx.moveTo(-this.size.width, i * -10)\n                this.ctx.lineTo(this.size.width, i * -10)\n            }\n            this.ctx.closePath()\n            this.ctx.stroke()\n\n            this.ctx.restore()\n        }\n\n        // Draw the node tree\n        const nodeTrees = this.nodeTrees || [];\n        nodeTrees.forEach(item => {\n            item.draw()\n        });\n\n    }\n}\n\n// Canvas garph\nclass CanvasGraph {\n    coreCanvas: CoreCanvas\n    canvas: HTMLCanvasElement\n    ctx: CanvasRenderingContext2D\n    needUpdate: boolean\n    constructor(dom: HTMLElement) {\n        const styleInfo = getComputedStyle(dom)\n        const size = {\n            width: parseFloat(styleInfo.width),\n            height: parseFloat(styleInfo.height)\n        }\n        this.coreCanvas = new CoreCanvas(size);\n\n        this.canvas = this.coreCanvas.canvas\n        this.ctx = this.coreCanvas.ctx\n\n        this.coreCanvas.draw()\n    }\n\n}\n\nexport { CanvasGraph }","import { AthenaMindmap } from '../athena-mindmap';\n\nnew AthenaMindmap('container')","import * as graph from './graph/canvas'\n\n// window.debug = true;\n\n/**\n * @class\n * @param {string} container the dom id where we put the mindmap\n */\nclass AthenaMindmap {\n    container: HTMLElement\n    graph: graph.CanvasGraph\n    ctx: CanvasRenderingContext2D\n    constructor(container: string, config?: object) {\n        this.container = document.getElementById(container);\n        this.graph = new graph.CanvasGraph(this.container);\n        // \n        console.log('Hello Athena!')\n        this.container.appendChild(this.graph.canvas)\n    }\n}\n\nexport { AthenaMindmap }"],"sourceRoot":""}