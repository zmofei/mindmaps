{"version":3,"sources":["webpack://AthenaMindmap/webpack/bootstrap","webpack://AthenaMindmap/webpack/runtime/make namespace object","webpack://AthenaMindmap/./src/graph/canvas/cavnas-node-types.ts","webpack://AthenaMindmap/./src/graph/canvas/nodeStyle.ts","webpack://AthenaMindmap/./src/graph/canvas/editor.ts","webpack://AthenaMindmap/./src/graph/canvas/nodes.ts","webpack://AthenaMindmap/./src/graph/canvas/creater.ts","webpack://AthenaMindmap/./src/dev/athena-dev.ts","webpack://AthenaMindmap/./src/athena-mindmap.ts"],"names":["__webpack_require__","exports","Symbol","toStringTag","Object","defineProperty","value","NodeType","NodeState","NodePadding","box","this","document","createElement","style","position","zIndex","dom","innerHTML","contentEditable","font","left","top","whiteSpace","minWidth","transform","appendChild","body","addEventListener","e","key","returnValue","events","new","forEach","fn","father","changeNode","id","after","done","fatherId","preventDefault","context","innerText","replace","show","x","y","width","height","scale","node","lastPosition","display","transformOrigin","lastNodeId","range","createRange","sel","window","getSelection","selectNodeContents","removeAllRanges","addRange","hide","onChange","type","push","editor","Editor","ctx","config","Date","toString","Math","random","Node","_state","Default","childrenSumHeight","outerHeight","computerSize","txt","measureText","_context","contextWidth","max","contextHeight","fontBoundingBoxAscent","fontBoundingBoxDescent","boxWidth","boxHeight","NodeMargin","outerWidth","bindTree","shakeTree","graph","draw","Edit","editoringNode","Root","item","NodeItem","rootid","tree","nodesRef","addNode","fatherid","afterid","edit","fatherItem","children","index","findIndex","splice","editItem","increateHeight","length","loopItem","loopItemId","stacks","info","fatherY","fatherX","items","keys","map","boardList","textList","linkList","stackItem","shift","listHgihtTrim","nextSilbingStartY","onlyChildren","itemY","state","drawBoard","list","selecteNode","save","listByType","listItem","selected","strokeStyle","beginPath","board","offset","translate","lineWidth","moveTo","lineTo","arc","PI","closePath","stroke","fillStyle","fill","lineCap","restore","drawNode","fillRect","debug","strokeRect","fillText","toFixed","drawText","textAlign","textBaseline","drawLink","startX","startY","endX","endY","deltaY","abs","middleX","endLowerThanStart","quadraticCurveTo","bezierCurveTo","updateEditor","dpr","devicePixelRatio","getTransform","ctxScale","ctxOffsetX","ctxOffsetY","nodeX","nodeY","screenOrignX","screenOrginY","offsetX","offsetY","size","canvas","getContext","adjustCanvs","bindEvent","tid","testNode","NodeTree","tid1xx","i","tid2xx","tid3xx","tid4xx","tid5xx","nodeTrees","moving","mousedownX","mousedownY","lastX","lastY","moveDelteX","moveDelteY","scaleRatio","stack","roodId","pop","xInBoundary","yBoundarys","yInBoundary","min","apply","nodeChildren","XinBox","YOffset","YinBox","cursor","hover","newTransform","a","f","scaleDelta","pow","setTransform","clearRect","xCount","round","yCount","styleInfo","getComputedStyle","parseFloat","coreCanvas","CoreCanvas","container","getElementById","console","log"],"mappings":"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","file":"athena-mindmap.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export enum NodeType {\n    Root = 'ROOT',\n    Node = 'NODE'\n}\n\nexport enum NodeState {\n    Edit = 'Edit',\n    Default = 'Default'\n}","import { NodeType } from './cavnas-node-types'\n\nconst NodeMargin = 10\nconst NodePadding = 10\nconst ListPadding = 100\n\n\nfunction drawNode(type: NodeType, ctx: CanvasRenderingContext2D, list: any) {\n    ctx.save()\n    ctx.strokeStyle = '#e99b47';\n    if (type === NodeType.Root) {\n        ctx.beginPath()\n        list.forEach((board: any) => {\n            const [item, offset] = board\n            const { context, boxHeight, boxWidth, outerHeight } = item\n            let { x, y } = offset\n            y = y + item.boxHeight / 2\n            ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n            const radius = 6;\n            ctx.lineWidth = 4\n            ctx.moveTo(-NodePadding, 0)\n            ctx.lineTo(-NodePadding, -boxHeight / 2 + radius)\n            ctx.arc(-NodePadding + radius, -boxHeight / 2 + radius, radius, Math.PI, Math.PI * (3 / 2))\n            ctx.lineTo(boxWidth - NodePadding - radius, -boxHeight / 2)\n            ctx.arc(boxWidth - NodePadding - radius, -boxHeight / 2 + radius, radius, Math.PI * (3 / 2), 2 * Math.PI)\n            ctx.lineTo(boxWidth - NodePadding, boxHeight / 2 - radius)\n            ctx.arc(boxWidth - NodePadding - radius, boxHeight / 2 - radius, radius, 2 * Math.PI, Math.PI * (1 / 2))\n            ctx.lineTo(-NodePadding + radius, boxHeight / 2)\n            ctx.arc(-NodePadding + radius, boxHeight / 2 - radius, radius, Math.PI / 2, Math.PI)\n            ctx.lineTo(-NodePadding, 0)\n            ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n        })\n        ctx.closePath()\n        ctx.stroke()\n        ctx.fillStyle = 'white'\n        ctx.fill()\n    } else if (type === NodeType.Node) {\n        ctx.beginPath()\n        list.forEach((board: any) => {\n            const [item, offset] = board\n            const { context, boxHeight, boxWidth, outerHeight } = item\n            const { x, y } = offset\n            ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n            ctx.lineCap = 'round';\n            ctx.lineWidth = 2\n            ctx.moveTo(-NodePadding, boxHeight / 2)\n            ctx.lineTo(item.boxWidth - NodePadding, boxHeight / 2)\n            ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n        })\n        ctx.closePath()\n        ctx.stroke()\n    }\n    ctx.restore()\n}\n\n\n\nexport { NodeType, NodeMargin, NodePadding, ListPadding, drawNode }","import { NodeItem } from \"./nodes\"\n\nexport class Editor {\n    box: HTMLElement\n    dom: HTMLElement\n    events: {\n        [key: string]: Function[]\n    }\n    changeNode: NodeItem\n    lastPosition: { x: number, y: number, scale: number }\n    renderTimeoutId: ReturnType<typeof setTimeout>\n    lastNodeId: string\n    constructor() {\n        const box = this.box = document.createElement('div')\n\n        box.style.position = 'absolute'\n        box.style.zIndex = '999'\n        this.dom = document.createElement('div')\n        this.dom.innerHTML = 'Hello'\n        this.dom.contentEditable = 'true'\n        this.dom.style.font = \"14px Arial\"\n        this.dom.style.position = 'absolute'\n        this.dom.style.left = '1px'\n        this.dom.style.top = '0'\n        this.dom.style.whiteSpace = 'nowrap'\n        this.dom.style.minWidth = '40px'\n\n        this.dom.style.transform = \"translate(0, -100%)\"\n        box.appendChild(this.dom)\n        document.body.style.position = 'relative'\n        document.body.appendChild(box)\n        // bind Change event\n        this.dom.addEventListener('keydown', (e) => {\n            if (e.key === 'Tab') {\n                e.returnValue = false\n                this.events.new = this.events.new || []\n                this.events.new.forEach(fn => {\n                    fn({\n                        father: this.changeNode.id,\n                        after: null\n                    })\n                })\n            }\n        })\n        // \n        this.dom.addEventListener('keypress', (e) => {\n            if (e.key === 'Enter') {\n                e.returnValue = false\n            }\n        })\n\n        this.dom.addEventListener('keyup', (e) => {\n            if (e.key === 'Enter') {\n                // console.log(1)\n                this.events.done.forEach(fn => {\n                    fn({\n                        father: this.changeNode.fatherId,\n                        after: this.changeNode.id\n                    })\n                })\n                e.preventDefault()\n            }\n        })\n        // \n        this.dom.addEventListener('input', (e) => {\n            this.changeNode.context = this.dom.innerText.replace(/\\n/gi, '')\n        })\n\n        // init events\n        this.events = {}\n\n    }\n\n    show(x: number, y: number, width: number, height: number, scale: number, node: NodeItem) {\n        const lastPosition = this.lastPosition || { x: 0, y: 0, scale: 0 }\n\n        this.changeNode = node\n        this.box.style.display = 'inline-block'\n        this.dom.style.transformOrigin = `bottom left`\n        this.box.style.transform = `translate(${x}px, ${y}px) scale(${scale / 2})`\n\n        const willUpdate = !(node.id === this.lastNodeId)\n        // focus to the dom only if we change the node\n        if (willUpdate) {\n            this.dom.innerText = node.context\n            var range = document.createRange()\n            var sel = window.getSelection()\n            range.selectNodeContents(this.dom)\n            sel.removeAllRanges()\n            sel.addRange(range)\n            this.lastNodeId = node.id\n        }\n        this.lastPosition = { x, y, scale }\n    }\n\n    hide() {\n        this.lastNodeId = null\n        this.box.style.display = 'none'\n    }\n\n    onChange(type: string, fn: Function) {\n        this.events[type] = this.events[type] || []\n        this.events[type].push(fn)\n    }\n\n}\n\n","import { NodeType, drawNode, NodeMargin, NodePadding, ListPadding, } from './nodeStyle'\nimport { NodeState } from './cavnas-node-types'\nimport { Editor } from './editor'\n\nconst editor = new Editor()\n\ninterface config {\n    context: string,\n    fatherId?: string,\n    type?: NodeType\n}\n\n\ntype renderListWithItem = [NodeItem, { x: number, y: number }][];\ntype renderListwithCoordinate = [number, number, number, number][]\n\n// editor: Editor\n// Bind edirot object\n//  this.editor = editor\n\nclass NodeItem {\n    ctx: CanvasRenderingContext2D\n    id: string\n    contextWidth: number\n    contextHeight: number\n    x: number\n    y: number\n    boxWidth: number\n    boxHeight: number\n    outerHeight: number\n    outerWidth: number\n    childrenSumHeight: number\n    children: NodeItem[]\n\n    selected: boolean\n    fatherId: string\n    father: NodeItem\n    type: NodeType\n    _state: NodeState\n    _groupindex: number\n    _context: string\n    bindTree: NodeTree\n    constructor(ctx: CanvasRenderingContext2D, config: config = { context: '', fatherId: null }) {\n        const id = (+new Date()).toString(32) + (Math.random().toString(32))\n        this.id = id\n        this.ctx = ctx\n        this.x = 0\n        this.y = 0\n        this.type = config.type ?? NodeType.Node\n        this._state = NodeState.Default\n\n        this.context = config.context\n        this.fatherId = config.fatherId || null\n\n        // \n        this.childrenSumHeight = this.outerHeight\n    }\n\n    computerSize() {\n        const ctx = this.ctx\n\n        ctx.font = \"14px Arial\";\n        const txt = this.ctx.measureText(this._context);\n        this.contextWidth = Math.max(txt.width, 40);\n        // @ts-ignore\n        this.contextHeight = txt.fontBoundingBoxAscent + txt.fontBoundingBoxDescent;\n        this.boxWidth = this.contextWidth + NodePadding * 2;\n        this.boxHeight = this.contextHeight + NodePadding * 2;\n        this.outerHeight = this.boxHeight + NodeMargin * 2\n        this.outerWidth = this.boxWidth + NodeMargin * 2\n    }\n\n    get context(): string {\n        return this._context\n    }\n    set context(value) {\n        this._context = value\n        this.computerSize()\n        this.bindTree?.shakeTree()\n        this.bindTree?.graph?.draw()\n    }\n\n    get state(): NodeState {\n        return this._state\n    }\n\n    set state(value) {\n        if (value === NodeState.Edit) {\n            this.bindTree.editoringNode = this\n        } else {\n            this.bindTree.editoringNode = null\n        }\n        this._state = value\n    }\n}\n\nclass NodeTree {\n    config: {\n        x: number,\n        y: number,\n        context?: string,\n        contextWidth?: number,\n        contextHeight?: number,\n    }\n\n    ctx: CanvasRenderingContext2D\n    tree: { [key: string]: NodeItem }\n    rootid: string\n    nodesRef: { [key: string]: NodeItem }\n    boardList: renderListWithItem\n    textList: renderListWithItem\n    linkList: renderListwithCoordinate\n    editoringNode: NodeItem\n    editor: Editor\n    graph: any\n\n    constructor(graph: any, config = { x: 0, y: 0, context: '', type: NodeType.Root }) {\n        this.graph = graph\n        const ctx = this.ctx = graph.ctx\n        const item = new NodeItem(ctx, { ...config, type: NodeType.Root });\n        this.rootid = item.id\n        this.tree = {}\n        this.tree[this.rootid] = item\n        this.nodesRef = this.nodesRef || {}\n        this.nodesRef[this.rootid] = item\n\n        // bind father\n        if (item.fatherId && this.tree[item.fatherId]) {\n            item.father = this.tree[item.fatherId]\n        }\n        item.bindTree = this\n\n        // bind editor and listen to the editor events\n        this.editor = editor\n        editor.onChange('done', ({ father, after }: { [key: string]: string }) => {\n            this.editoringNode = null\n            this.graph.draw()\n        })\n\n    }\n\n    addNode(config = { context: '' }, fatherid?: string, afterid?: string, edit?: boolean) {\n\n        const fatherId = fatherid || this.rootid;\n        const fatherItem = this.nodesRef[fatherId];\n        const item = new NodeItem(this.ctx, {\n            ...config,\n            fatherId: fatherId\n        });\n\n        // add item to fater\n        const children = fatherItem.children = fatherItem.children || [];\n        // fatherItem.children = fatherItem.children || []\n\n        // if we have afterid we have to put the new item after the id\n        // else we can add the new node to the end of the list\n        if (afterid) {\n            const index = children.findIndex(item => { return item.id === afterid });\n            if (index !== -1) {\n                children.splice(index + 1, 0, item)\n            } else {\n                return false;\n            }\n        } else {\n            children.push(item)\n        }\n\n        if (edit) {\n            // this.graph.selected && (this.graph.selected.selected = false);\n            // this.graph.selected = item;\n            // item.selected = true\n            this.graph.editItem = item\n            this.editoringNode = item\n        }\n\n        this.nodesRef[item.id] = item\n\n        // bind father\n        if (item.fatherId && this.tree[item.fatherId]) {\n            item.father = fatherItem\n        }\n        item.bindTree = this\n\n        // Re-computer position\n        // Height: update the height of all the affected nodes from parent to root\n        const onlyChildren = children.length <= 1\n        const increateHeight = onlyChildren ? 0 : item.outerHeight\n        let loopItem = item;\n        while (loopItem) {\n            const loopItemId = loopItem.fatherId\n            const fatherItem = this.nodesRef[loopItemId];\n            if (!loopItemId || !fatherItem) {\n                loopItem = null\n            } else {\n                fatherItem.childrenSumHeight += increateHeight\n                loopItem = fatherItem\n            }\n        }\n\n        // x,y\n        // A Node added may cause all the tree's layout change\n        // we need to restracture all the x,y for the tree.\n        this.shakeTree()\n\n        // \n        this.graph.draw()\n\n        // \n        return item.id\n    }\n\n    // Reset all the node's position\n    shakeTree() {\n        interface drawInfo {\n            x: number\n            fatherY: number,\n            fatherX: number,\n            father?: NodeItem\n        }\n\n        const root = Object.keys(this.tree).map(id => this.nodesRef[id]);\n        const stacks: { info: drawInfo, items: NodeItem[] }[] = [{ info: { x: 0, fatherY: 0, fatherX: 0, }, items: root }];\n\n        const boardList: [NodeItem, { x: number, y: number }][] = [];\n        const textList: [NodeItem, { x: number, y: number }][] = [];\n        const linkList: [number, number, number, number][] = [];\n\n        let editingNode = null\n\n        while (stacks.length > 0) {\n            const stackItem = stacks.shift();\n\n            const info = stackItem.info;\n            const items = stackItem.items;\n\n            let listHgihtTrim = 0;\n            items.forEach((item, index) => {\n                listHgihtTrim += item.childrenSumHeight\n            })\n\n            const listStartY = info.fatherY - listHgihtTrim / 2\n\n            let nextSilbingStartY = listStartY\n            const onlyChildren = items.length === 1\n            items.forEach((item, index) => {\n                let itemY;\n                if (onlyChildren) {\n                    itemY = info.fatherY\n                } else {\n                    itemY = nextSilbingStartY + item.childrenSumHeight / 2\n                    nextSilbingStartY += item.childrenSumHeight\n                }\n                item.x = info.x\n                item.y = itemY\n\n                boardList.push([item, { x: info.x, y: itemY }])\n\n                textList.push([item, { x: info.x, y: itemY }])\n\n\n                if (info.father) {\n                    linkList.push([\n                        info.fatherX + info.father.boxWidth,\n                        info.fatherY,\n                        info.x,\n                        itemY\n                    ])\n                }\n\n                // \n                if (item.state === NodeState.Edit) {\n                    editingNode = item\n                }\n\n                const children = item.children;\n                if (children) {\n                    stacks.push({ info: { x: info.x + item.boxWidth + ListPadding, fatherY: itemY, fatherX: info.x, father: item }, items: children })\n                }\n            })\n        }\n\n        this.boardList = boardList;\n        this.textList = textList;\n        this.linkList = linkList;\n    }\n\n    // draw board box\n    drawBoard() {\n        const list = this.boardList || []\n        const ctx = this.ctx\n        const selecteNode: NodeItem[] = []\n        ctx.save()\n        const listByType: {\n            [key: string]: {\n                type: NodeType,\n                list: renderListwithCoordinate | renderListWithItem\n            }\n        } = {}\n\n        list.forEach(listItem => {\n            const [NodeItem] = listItem\n            if (NodeItem.selected) {\n                selecteNode.push(NodeItem)\n            }\n            listByType[NodeItem.type] = listByType[NodeItem.type] || {\n                type: NodeItem.type,\n                list: []\n            }\n            // @ts-ignore\n            listByType[NodeItem.type].list.push(listItem)\n        })\n\n        Object.keys(listByType).forEach(type => {\n            const list = listByType[type];\n            drawNode(list.type, this.ctx, list.list);\n        })\n        ctx.restore()\n\n        // draw selected\n        ctx.save()\n        selecteNode?.forEach(node => {\n            this.ctx.fillStyle = 'rgba(0,102,255,0.2)'\n            if (node.type === NodeType.Root) {\n                this.ctx.fillRect(node.x, node.y - node.boxHeight / 2, node.boxWidth, node.boxHeight)\n            } else {\n                this.ctx.fillRect(node.x, node.y - node.boxHeight, node.boxWidth, node.boxHeight)\n            }\n        })\n        ctx.restore()\n\n        // for debug\n        if (window.debug) {\n            list.forEach(board => {\n                const [item, offset] = board\n                const { x, y } = offset\n                // origin\n                ctx.save()\n                ctx.fillStyle = 'red'\n                ctx.translate(x, y)\n                ctx.fillRect(-2, -2, 4, 4)\n                ctx.restore()\n                // group\n                ctx.save()\n                ctx.fillStyle = 'red'\n                ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n                this.ctx.strokeStyle = 'red'\n                ctx.strokeRect(-NodePadding, -item.childrenSumHeight / 2, item.boxWidth, item.childrenSumHeight)\n                ctx.restore()\n\n                // context\n                ctx.save()\n                ctx.translate(x, y)\n                ctx.translate(NodePadding, -item.boxHeight / 2)\n                ctx.strokeRect(0, -item.contextHeight / 2, item.contextWidth, item.contextHeight)\n                ctx.restore()\n                // outer\n                ctx.save()\n                ctx.strokeStyle = 'grey'\n                ctx.translate(x, y)\n                ctx.translate(-NodePadding, -item.boxHeight - NodeMargin)\n                ctx.strokeRect(0, 0, item.outerWidth, item.outerHeight)\n                ctx.restore()\n                // box\n                ctx.save()\n                ctx.strokeStyle = 'yellow'\n                ctx.translate(x, y)\n                ctx.translate(0, -item.boxHeight)\n                ctx.strokeRect(0, 0, item.boxWidth, item.boxHeight)\n                ctx.restore()\n\n\n                // Tips text\n                ctx.save()\n                ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n                this.ctx.fillStyle = 'red'\n                ctx.font = \"10px Arial\";\n                ctx.fillText((item.childrenSumHeight).toFixed(2).toString(), item.boxWidth, NodePadding * 2 - item.boxHeight)\n                ctx.fillText((item.outerHeight).toFixed(2).toString(), item.boxWidth, NodePadding * 2 - item.boxHeight + 10)\n                ctx.fillText(`${(item.x).toFixed(0).toString()},${(item.y || 0).toFixed(0).toString()} `, item.boxWidth, NodePadding * 2 - item.boxHeight + 20)\n                ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n                ctx.restore()\n\n            })\n\n        }\n    }\n\n    drawText() {\n        const list = this.textList || []\n        const ctx = this.ctx\n        ctx.save()\n        ctx.textAlign = 'left'\n        ctx.textBaseline = 'middle'\n\n        list.forEach(board => {\n            const [item, offset] = board\n            if (item === this.editoringNode) return false\n            let { x, y } = offset\n            if (item.type === NodeType.Root) {\n                y = y + item.boxHeight / 2\n            }\n            ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n            const { context, boxHeight, boxWidth, outerHeight } = item\n            ctx.font = \"14px Arial\";\n            ctx.fillText(context, 0, 0)\n            ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n        })\n        ctx.restore()\n    }\n\n    drawLink() {\n        const list = this.linkList || []\n        const ctx = this.ctx\n        ctx.save()\n        ctx.strokeStyle = '#e99b47';\n        ctx.beginPath()\n        list.forEach(board => {\n\n            //                                    (endX, endY)\n            //                              ---------- B\n            //                             |\n            //          A --------(middleX, startY)\n            //  (startX, startY)           |\n            //                              ---------- C\n            //                                    (endX, endY)\n\n            const [startX, startY, endX, endY] = board;\n            const deltaY = Math.abs(endY - startY);\n            const radius = 6;\n            const middleX = (startX + endX) / 2;\n            const endLowerThanStart = endY < startY;\n\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(middleX - radius, startY);\n            // inflection\n            if (deltaY / 2 >= radius) {\n                ctx.quadraticCurveTo(middleX, startY, middleX, startY + (endLowerThanStart ? -radius : radius))\n                ctx.lineTo(middleX, endY + (endLowerThanStart ? radius : -radius));\n                ctx.quadraticCurveTo(middleX, endY, middleX + radius, endY)\n            } else {\n                ctx.bezierCurveTo(middleX, startY, middleX, endY, middleX + radius, endY)\n            }\n            // \n            ctx.lineTo(endX, endY)\n        })\n        ctx.stroke()\n        ctx.closePath()\n    }\n\n    updateEditor() {\n        const node = this.editoringNode;\n        const dpr = window.devicePixelRatio || 1\n        if (!node) {\n            editor.hide()\n            return;\n        }\n        // TODO: Show the editor \n        const { a: ctxScale, e: ctxOffsetX, f: ctxOffsetY } = this.ctx.getTransform()\n\n        const { x: nodeX, y: nodeY, contextWidth, contextHeight } = node\n\n        const [screenOrignX, screenOrginY] = [(ctxOffsetX + nodeX * ctxScale) / dpr, (ctxOffsetY + nodeY * ctxScale) / dpr]\n\n        let offsetX = 0;\n        let offsetY = 0;\n        if (node.type === NodeType.Node) {\n            offsetX = NodePadding * (ctxScale / dpr)\n            offsetY -= NodePadding * (ctxScale / dpr)\n        } else if (node.type === NodeType.Root) {\n            offsetX = NodePadding * (ctxScale / dpr)\n            offsetY += (NodePadding - 2) * (ctxScale / dpr)\n        }\n\n\n        editor.show(screenOrignX + offsetX, screenOrginY + offsetY, contextWidth, contextHeight, ctxScale, node)\n\n    }\n\n    draw() {\n        // draw components step by step\n        this.drawBoard()\n        this.drawText()\n        this.drawLink()\n        this.updateEditor()\n    }\n}\n\n\nexport { NodeItem, NodeTree }","// This file is to create the init Canvas document and set up the resolution and other stuffs.\n// @ts-nocheck\n\nimport { NodeItem, NodeTree } from './nodes'\nimport { NodeType, NodeState } from './cavnas-node-types'\n\ninterface size {\n    width: number,\n    height: number\n}\n\nclass CoreCanvas {\n    canvas: HTMLCanvasElement\n    ctx: CanvasRenderingContext2D\n    offset: {\n        x: number,\n        y: number,\n    }\n    events: any\n    scale: number\n    nodeTrees: NodeItem[]\n    hover: NodeItem\n    selected: NodeItem\n    editItem: NodeItem\n    size: size\n    dpr: number\n\n    constructor(size: size) {\n        this.dpr = window.devicePixelRatio || 1\n        this.scale = this.dpr;\n        this.size = size\n        this.offset = { x: size.width / 2 * this.scale, y: size.height / 2 * this.scale }\n        this.events = {}\n\n        const canvas = this.canvas = document.createElement('canvas')\n        this.ctx = canvas.getContext('2d')\n        window.ctx = this.ctx\n\n        this.adjustCanvs(canvas, size);\n        this.bindEvent()\n\n        // TEST\n        // addNode\n        const testNode = window.testNode = new NodeTree(this, {\n            x: 0,\n            y: 0,\n            context: '雅典娜的图'\n        })\n\n        let tid = 0;\n        tid = testNode.addNode({\n            context: 'HTTP CODE'\n        })\n\n        let tid1xx = testNode.addNode({\n            context: '1xx'\n        }, tid)\n\n        for (let i of ['100 Continue', '101 Switching Protocol', '102 Processing', '103 Early Hints']) {\n            testNode.addNode({\n                context: i\n            }, tid1xx)\n        }\n\n        let tid2xx = testNode.addNode({\n            context: '2xx'\n        }, tid)\n\n        for (let i of ['200 OK', '201 Created', '202 Accepted', '203 Non-Authoritative Information', '204 No Content', '205 Reset Content', '206 Partial Content']) {\n            testNode.addNode({\n                context: i\n            }, tid2xx)\n        }\n\n        let tid3xx = testNode.addNode({\n            context: '3xx'\n        }, tid)\n\n\n        for (let i of ['300 Multiple Choices', '301 Moved Permanently', '302 Found', '3', '3 See Other', '304 Not Modified', '307 Temporary Redirect', '308 Permanent Redirect']) {\n            testNode.addNode({\n                context: i\n            }, tid3xx)\n        }\n\n\n        let tid4xx = testNode.addNode({\n            context: '4xx'\n        }, tid)\n\n\n        for (let i of ['400 Bad Request',\n            '401 Unauthorized',\n            '402 Payment Required',\n            '403 Forbidden',\n            '404 Not Found',\n            '405 Method Not Allowed',\n            '406 Not Acceptable',\n            '407 Proxy Authentication Required',\n            '408 Request Timeout',\n            '409 Conflict',\n            '410 Gone',\n            '411 Length Required',\n            '412 Precondition Failed',\n            '413 Payload Too Large',\n            '414 URI Too Long',\n            '415 Unsupported Media Type',\n            '416 Range Not Satisfiable',\n            '417 Expectation Failed',\n            '418 I\\'m a teapot',\n            '422 Unprocessable Entity',\n            '425 Too Early',\n            '426 Upgrade Required',\n            '428 Precondition Required',\n            '429 Too Many Requests',\n            '431 Request Header Fields Too Large',\n            '451 Unavailable For Legal Reasons']) {\n            testNode.addNode({\n                context: i\n            }, tid4xx)\n        }\n\n\n        let tid5xx = testNode.addNode({\n            context: '5xx'\n        }, tid)\n\n\n        for (let i of ['500 Internal Server Error',\n            '501 Not Implemented',\n            '502 Bad Gateway',\n            '503 Service Unavailable',\n            '504 Gateway Timeout',\n            '505 HTTP Version Not Supported',\n            '506 Variant Also Negotiates',\n            '507 Insufficient Storage',\n            '508 Loop Detected',\n            '510 Not Extended',\n            '511 Network Authentication Required']) {\n            testNode.addNode({\n                context: i\n            }, tid5xx)\n        }\n\n\n\n        this.nodeTrees = [testNode]\n    }\n\n    adjustCanvs(canvas: HTMLCanvasElement, size: size) {\n        // Get the device pixel ratio, falling back to 1.\n\n        // Give the canvas pixel dimensions of their CSS\n        // size * the device pixel ratio.\n        canvas.style.width = `${size.width}px`;\n        canvas.style.height = `${size.height}px`;\n        canvas.width = size.width * this.dpr;\n        canvas.height = size.height * this.dpr;\n        this.ctx.translate(this.offset.x, this.offset.y)\n        this.ctx.scale(this.dpr, this.dpr)\n    }\n\n    // The events Config the canvas by translate and scale, so that NodeItems don't need to care about the translate and scale\n    bindEvent() {\n        const canvas = this.canvas;\n        let moving = 'DONE';\n        let mousedownX = null;\n        let mousedownY = null;\n        let lastX = null;\n        let lastY = null;\n\n        canvas.addEventListener('mousedown', (e) => {\n            moving = 'PREPARE';\n            lastX = mousedownX = e.offsetX\n            lastY = mousedownY = e.offsetY\n\n            if (this.editItem) {\n                // Clean the Editor model\n                this.editItem?.state = NodeState.Default\n                this.editItem = null\n                this.draw()\n            }\n        });\n\n        canvas.addEventListener('mousemove', (e) => {\n            if (moving === 'PREPARE' || moving === 'MOVING') {\n                // Moving modle\n                // In moving modle we translate the canvas, \n                //   so that in the node tree draw step, \n                //   the nodes don't need to consider the canvas translate.\n                const { dpr, scale, offset } = this\n                const moveDelteX = e.offsetX - lastX;\n                const moveDelteY = e.offsetY - lastY;\n                const scaleRatio = (scale / dpr);\n                lastY = e.offsetY\n                lastX = e.offsetX\n                moving = 'MOVING'\n\n                this.ctx.translate(moveDelteX / scaleRatio, moveDelteY / scaleRatio)\n\n                this.draw()\n            } else {\n                // Free move modle\n                // In free modle, we calculate the mouse's relation with the nodes,\n                //   and save the hovered node to this.hover\n                const onCanvasX = (e.offsetX * this.dpr - this.offset.x) / this.scale\n                const onCanvasY = (e.offsetY * this.dpr - this.offset.y) / this.scale\n\n                let matchedNode = null;\n                // Loop the tree's position\n                this.nodeTrees.forEach(({ tree }) => {\n                    const stack = [Object.keys(tree).map(roodId => tree[roodId])];\n                    while (stack.length >= 1) {\n                        const nodes = stack.pop();\n\n                        for (let node of nodes) {\n                            const xInBoundary = node.x >= 0 ? (onCanvasX >= node.x) : (onCanvasX <= node.x)\n                            const yBoundarys = [node.y - node.childrenSumHeight, node.y + node.childrenSumHeight]\n                            const yInBoundary = onCanvasY >= Math.min.apply(null, yBoundarys) && onCanvasY <= Math.max.apply(null, yBoundarys)\n                            const nodeChildren = node.children\n                            if (xInBoundary && yInBoundary) {\n                                // math Node\n                                //  -----------------         -----------------\n                                // |                 |       |                 |\n                                // .(x,y) ROOOT      |       |    Others       |\n                                // |                 |       |                 |\n                                //  -----------------        .(x,y)------------\n                                // If the node type is root the origin is in the left-middle\n                                // Other whise the origin is in the left-bottom\n                                const XinBox = onCanvasX >= node.x && onCanvasX <= node.x + node.boxWidth\n                                let YOffset = node.type === NodeType.Root ? node.boxHeight / 2 : 0\n                                const YinBox = onCanvasY >= (node.y - node.boxHeight + YOffset) && onCanvasY <= (node.y + YOffset)\n                                if (XinBox && YinBox) {\n                                    matchedNode = node\n                                    stack.length = 0\n                                    break\n                                }\n\n                                if (nodeChildren) {\n                                    stack.push(nodeChildren)\n                                }\n                            }\n                        }\n                    }\n                })\n\n                if (matchedNode) {\n                    this.canvas.style.cursor = 'pointer'\n                } else {\n                    this.canvas.style.cursor = 'default'\n                }\n\n                this.hover = matchedNode\n            }\n        });\n\n        canvas.addEventListener('mouseup', (e) => {\n            e.preventDefault()\n            moving = 'DONE'\n            lastX = lastY = null\n            const newTransform = this.ctx.getTransform()\n            this.scale = newTransform.a\n            this.offset = {\n                x: newTransform.e,\n                y: newTransform.f\n            }\n        });\n\n        canvas.addEventListener('wheel', (e) => {\n            const { dpr, scale, offset } = this\n            e.preventDefault();\n\n            const scaleDelta = Math.pow(1.01, -e.deltaY);\n            const scaleRatio = (scale / dpr);\n\n            ctx.setTransform(scale, 0, 0, scale, offset.x, offset.y)\n            this.ctx.translate(-offset.x / scale + e.offsetX / scaleRatio, -offset.y / scale + e.offsetY / scaleRatio)\n            this.ctx.scale(scaleDelta, scaleDelta)\n            this.ctx.translate(-(-offset.x / scale + e.offsetX / scaleRatio), -(-offset.y / scale + e.offsetY / scaleRatio))\n\n            const newTransform = this.ctx.getTransform()\n            this.scale = newTransform.a\n            this.offset = {\n                x: newTransform.e,\n                y: newTransform.f\n            }\n\n            this.draw()\n        });\n\n        canvas.addEventListener('click', (e) => {\n            // Prevent trigger the click event while you movingthe canvas\n            if (Math.abs(e.offsetX - mousedownX) > 5 || Math.abs(e.offsetY - mousedownY) > 5) return false;\n\n            this.selected?.selected = false\n            // If you click the Node twice the node will become the Editor mode\n            // Otherwise the Node will exit the Editor mode\n            if (this.hover && this.selected === this.hover) {\n                this.selected = null\n                this.hover.state = NodeState.Edit\n                this.editItem = this.hover\n            } else if (this.hover !== this.editItem) {\n                this.editItem?.state = NodeState.Default\n                this.editItem = null\n                // Re assign the select Node\n                this.selected = this.hover;\n                this.selected?.selected = true;\n            }\n            this.draw();\n        })\n\n        window.addEventListener('keyup', (e) => {\n            const NodeTree = this.nodeTrees[0];\n            if (e.key === 'Enter') {\n                // console.log(NodeTree.editoringNode)\n                if (this.editItem) {\n                    // If you press enter, and if we have the edit node, we will quit the edit mode by:\n                    // 1. set the editor node as seleced node\n                    this.editItem.selected = true\n                    this.selected = this.editItem\n                    // 2. set the editItem to null\n                    this.editItem.state = NodeState.Default;\n                    this.editItem = null;\n                } else if (this.selected) {\n                    // If we have the selected node, we will enter the edit mode by\n                    const { fatherId, id } = this.selected;\n                    // 1. clean the selected node\n                    this.selected && (this.selected.selected = false)\n                    this.selected = null;\n                    // 2. add a new editor and set it to the editor mode\n                    NodeTree.addNode({ context: 'New Node' }, fatherId, id, true)\n                }\n                this.draw()\n            }\n        })\n    }\n\n    // Draw Nodetree\n    // 1. Clean the canvas\n    // 2. Call the draw function from the Node tree\n    draw() {\n        const ctx = this.ctx;\n        // Reset the canvas and clean it\n        ctx.save()\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n        ctx.fillStyle = '#f3f3f4'\n        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n        ctx.restore();\n\n\n        // \n        if (window.debug) {\n            // origin \n            this.ctx.save()\n            this.ctx.beginPath()\n            this.ctx.strokeStyle = 'red'\n            this.ctx.lineWidth = 2\n            this.ctx.moveTo(0, -5)\n            this.ctx.lineTo(0, 5)\n            this.ctx.moveTo(-5, 0)\n            this.ctx.lineTo(5, 0)\n            this.ctx.stroke()\n            this.ctx.closePath()\n\n            // gird\n            this.ctx.beginPath()\n            this.ctx.strokeStyle = '#ddd'\n            const xCount = Math.round(this.size.width / 10)\n            for (let i = -xCount; i < xCount; i += 1) {\n                this.ctx.moveTo(i * -10, -this.size.height)\n                this.ctx.lineTo(i * -10, this.size.height)\n            }\n            const yCount = Math.round(this.size.height / 10)\n            for (let i = -yCount; i < yCount; i += 1) {\n                this.ctx.moveTo(-this.size.width, i * -10)\n                this.ctx.lineTo(this.size.width, i * -10)\n            }\n            this.ctx.closePath()\n            this.ctx.stroke()\n\n            this.ctx.restore()\n        }\n\n        // Draw the node tree\n        const nodeTrees = this.nodeTrees || [];\n        nodeTrees.forEach(item => {\n            item.draw()\n        });\n\n    }\n}\n\n// Canvas garph\nclass CanvasGraph {\n    coreCanvas: CoreCanvas\n    canvas: HTMLCanvasElement\n    ctx: CanvasRenderingContext2D\n    needUpdate: boolean\n    constructor(dom: HTMLElement) {\n        const styleInfo = getComputedStyle(dom)\n        const size = {\n            width: parseFloat(styleInfo.width),\n            height: parseFloat(styleInfo.height)\n        }\n        this.coreCanvas = new CoreCanvas(size);\n\n        this.canvas = this.coreCanvas.canvas\n        this.ctx = this.coreCanvas.ctx\n\n        this.coreCanvas.draw()\n    }\n\n}\n\nexport { CanvasGraph }","import { AthenaMindmap } from '../athena-mindmap';\n\nnew AthenaMindmap('container')","import * as graph from './graph/canvas'\n\n// window.debug = true;\n\n/**\n * @class\n * @param {string} container the dom id where we put the mindmap\n */\nclass AthenaMindmap {\n    container: HTMLElement\n    graph: graph.CanvasGraph\n    ctx: CanvasRenderingContext2D\n    constructor(container: string, config?: object) {\n        this.container = document.getElementById(container);\n        this.graph = new graph.CanvasGraph(this.container);\n        // \n        console.log('Hello Athena!')\n        this.container.appendChild(this.graph.canvas)\n    }\n}\n\nexport { AthenaMindmap }"],"sourceRoot":""}