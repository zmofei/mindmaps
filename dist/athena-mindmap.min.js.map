{"version":3,"sources":["webpack://AthenaMindmap/webpack/bootstrap","webpack://AthenaMindmap/webpack/runtime/make namespace object","webpack://AthenaMindmap/./src/graph/canvas/cavnas-node-types.ts","webpack://AthenaMindmap/./src/graph/canvas/nodeStyle.ts","webpack://AthenaMindmap/./src/graph/canvas/editor.ts","webpack://AthenaMindmap/./src/graph/canvas/nodes.ts","webpack://AthenaMindmap/./src/graph/canvas/creater.ts","webpack://AthenaMindmap/./src/dev/athena-dev.ts","webpack://AthenaMindmap/./src/athena-mindmap.ts"],"names":["__webpack_require__","exports","Symbol","toStringTag","Object","defineProperty","value","NodeType","NodeState","NodePadding","box","this","document","createElement","style","position","zIndex","dom","innerHTML","contentEditable","font","left","top","whiteSpace","minWidth","transform","appendChild","body","addEventListener","e","key","returnValue","events","new","forEach","fn","father","changeNode","id","after","fatherId","context","innerText","replace","show","x","y","width","height","scale","node","lastPosition","display","transformOrigin","lastNodeId","range","createRange","sel","window","getSelection","selectNodeContents","removeAllRanges","addRange","hide","onChange","type","push","editor","Editor","ctx","config","Date","toString","Math","random","Node","_state","Default","childrenSumHeight","outerHeight","computerSize","txt","measureText","_context","contextWidth","max","contextHeight","fontBoundingBoxAscent","fontBoundingBoxDescent","boxWidth","boxHeight","NodeMargin","outerWidth","bindTree","shakeTree","graph","draw","Edit","editoringNode","Root","item","NodeItem","rootid","tree","nodesRef","addNode","console","log","fatherid","afterid","edit","fatherItem","children","index","findIndex","splice","selected","increateHeight","length","loopItem","loopItemId","stacks","info","fatherY","fatherX","items","keys","map","boardList","textList","linkList","stackItem","shift","listHgihtTrim","nextSilbingStartY","onlyChildren","itemY","state","drawBoard","list","selecteNode","save","listByType","listItem","strokeStyle","beginPath","board","offset","translate","lineWidth","moveTo","lineTo","arc","PI","closePath","stroke","fillStyle","fill","lineCap","restore","drawNode","fillRect","debug","strokeRect","fillText","toFixed","drawText","textAlign","textBaseline","drawLink","startX","startY","endX","endY","deltaY","abs","middleX","endLowerThanStart","quadraticCurveTo","bezierCurveTo","updateEditor","dpr","devicePixelRatio","getTransform","ctxScale","ctxOffsetX","ctxOffsetY","nodeX","nodeY","screenOrignX","screenOrginY","offsetX","offsetY","size","canvas","getContext","adjustCanvs","bindEvent","testNode","NodeTree","tid","nodeTrees","moving","mousedownX","mousedownY","lastX","lastY","editItem","moveDelteX","moveDelteY","scaleRatio","stack","roodId","pop","xInBoundary","yInBoundary","nodeChildren","XinBox","YOffset","YinBox","cursor","hover","preventDefault","newTransform","a","f","scaleDelta","pow","setTransform","clearRect","xCount","round","i","yCount","styleInfo","getComputedStyle","parseFloat","coreCanvas","CoreCanvas","container","getElementById"],"mappings":"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","file":"athena-mindmap.min.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export enum NodeType {\n    Root = 'ROOT',\n    Node = 'NODE'\n}\n\nexport enum NodeState {\n    Edit = 'Edit',\n    Default = 'Default'\n}","import { NodeType } from './cavnas-node-types'\n\nconst NodeMargin = 10\nconst NodePadding = 10\nconst ListPadding = 100\n\n\nfunction drawNode(type: NodeType, ctx: CanvasRenderingContext2D, list: any) {\n    ctx.save()\n    ctx.strokeStyle = '#e99b47';\n    if (type === NodeType.Root) {\n        ctx.beginPath()\n        list.forEach((board: any) => {\n            const [item, offset] = board\n            const { context, boxHeight, boxWidth, outerHeight } = item\n            let { x, y } = offset\n            y = y + item.boxHeight / 2\n            ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n            const radius = 6;\n            ctx.lineWidth = 4\n            ctx.moveTo(-NodePadding, 0)\n            ctx.lineTo(-NodePadding, -boxHeight / 2 + radius)\n            ctx.arc(-NodePadding + radius, -boxHeight / 2 + radius, radius, Math.PI, Math.PI * (3 / 2))\n            ctx.lineTo(boxWidth - NodePadding - radius, -boxHeight / 2)\n            ctx.arc(boxWidth - NodePadding - radius, -boxHeight / 2 + radius, radius, Math.PI * (3 / 2), 2 * Math.PI)\n            ctx.lineTo(boxWidth - NodePadding, boxHeight / 2 - radius)\n            ctx.arc(boxWidth - NodePadding - radius, boxHeight / 2 - radius, radius, 2 * Math.PI, Math.PI * (1 / 2))\n            ctx.lineTo(-NodePadding + radius, boxHeight / 2)\n            ctx.arc(-NodePadding + radius, boxHeight / 2 - radius, radius, Math.PI / 2, Math.PI)\n            ctx.lineTo(-NodePadding, 0)\n            ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n        })\n        ctx.closePath()\n        ctx.stroke()\n        ctx.fillStyle = 'white'\n        ctx.fill()\n    } else if (type === NodeType.Node) {\n        ctx.beginPath()\n        list.forEach((board: any) => {\n            const [item, offset] = board\n            const { context, boxHeight, boxWidth, outerHeight } = item\n            const { x, y } = offset\n            ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n            ctx.lineCap = 'round';\n            ctx.lineWidth = 2\n            ctx.moveTo(-NodePadding, boxHeight / 2)\n            ctx.lineTo(item.boxWidth - NodePadding, boxHeight / 2)\n            ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n        })\n        ctx.closePath()\n        ctx.stroke()\n    }\n    ctx.restore()\n}\n\n\n\nexport { NodeType, NodeMargin, NodePadding, ListPadding, drawNode }","import { NodeItem } from \"./nodes\"\n\nexport class Editor {\n    box: HTMLElement\n    dom: HTMLElement\n    events: {\n        [key: string]: Function[]\n    }\n    changeNode: NodeItem\n    lastPosition: { x: number, y: number, scale: number }\n    renderTimeoutId: ReturnType<typeof setTimeout>\n    lastNodeId: string\n    constructor() {\n        const box = this.box = document.createElement('div')\n\n        box.style.position = 'absolute'\n        box.style.zIndex = '999'\n        this.dom = document.createElement('div')\n        this.dom.innerHTML = 'Hello'\n        this.dom.contentEditable = 'true'\n        this.dom.style.font = \"14px Arial\"\n        this.dom.style.position = 'absolute'\n        this.dom.style.left = '1px'\n        this.dom.style.top = '0'\n        this.dom.style.whiteSpace = 'nowrap'\n        this.dom.style.minWidth = '40px'\n\n        this.dom.style.transform = \"translate(0, -100%)\"\n        box.appendChild(this.dom)\n        document.body.style.position = 'relative'\n        document.body.appendChild(box)\n        // bind Change event\n        this.dom.addEventListener('keydown', (e) => {\n            if (e.key === 'Tab') {\n                e.returnValue = false\n                this.events.new = this.events.new || []\n                this.events.new.forEach(fn => {\n                    fn({\n                        father: this.changeNode.id,\n                        after: null\n                    })\n                })\n            }\n        })\n        // \n        this.dom.addEventListener('keypress', (e) => {\n            if (e.key === 'Enter') {\n                e.returnValue = false\n                this.events.new.forEach(fn => {\n                    fn({\n                        father: this.changeNode.fatherId,\n                        after: this.changeNode.id\n                    })\n                })\n            }\n        })\n        // \n        this.dom.addEventListener('input', (e) => {\n            this.changeNode.context = this.dom.innerText.replace(/\\n/gi, '')\n        })\n\n        // init events\n        this.events = {}\n\n    }\n\n    show(x: number, y: number, width: number, height: number, scale: number, node: NodeItem) {\n        const lastPosition = this.lastPosition || { x: 0, y: 0, scale: 0 }\n\n        this.changeNode = node\n        this.box.style.display = 'inline-block'\n        this.dom.style.transformOrigin = `bottom left`\n        this.box.style.transform = `translate(${x}px, ${y}px) scale(${scale / 2})`\n\n        const willUpdate = !(node.id === this.lastNodeId)\n        // focus to the dom only if we change the node\n        if (willUpdate) {\n            this.dom.innerText = node.context\n            var range = document.createRange()\n            var sel = window.getSelection()\n            range.selectNodeContents(this.dom)\n            sel.removeAllRanges()\n            sel.addRange(range)\n            this.lastNodeId = node.id\n        }\n        this.lastPosition = { x, y, scale }\n    }\n\n    hide() {\n        this.lastNodeId = null\n        this.box.style.display = 'none'\n    }\n\n    onChange(type: string, fn: Function) {\n        this.events[type] = this.events[type] || []\n        this.events[type].push(fn)\n    }\n\n}\n\n","import { NodeType, drawNode, NodeMargin, NodePadding, ListPadding, } from './nodeStyle'\nimport { NodeState } from './cavnas-node-types'\nimport { Editor } from './editor'\n\nconst editor = new Editor()\n\ninterface config {\n    context: string,\n    fatherId?: string,\n    type?: NodeType\n}\n\n\ntype renderListWithItem = [NodeItem, { x: number, y: number }][];\ntype renderListwithCoordinate = [number, number, number, number][]\n\n// editor: Editor\n// Bind edirot object\n//  this.editor = editor\n\nclass NodeItem {\n    ctx: CanvasRenderingContext2D\n    id: string\n    contextWidth: number\n    contextHeight: number\n    x: number\n    y: number\n    boxWidth: number\n    boxHeight: number\n    outerHeight: number\n    outerWidth: number\n    childrenSumHeight: number\n    children: NodeItem[]\n\n    selected: boolean\n    fatherId: string\n    father: NodeItem\n    type: NodeType\n    _state: NodeState\n    _groupindex: number\n    _context: string\n    bindTree: NodeTree\n    constructor(ctx: CanvasRenderingContext2D, config: config = { context: '', fatherId: null }) {\n        const id = (+new Date()).toString(32) + (Math.random().toString(32))\n        this.id = id\n        this.ctx = ctx\n        this.x = 0\n        this.y = 0\n        this.type = config.type ?? NodeType.Node\n        this._state = NodeState.Default\n\n        this.context = config.context\n        this.fatherId = config.fatherId || null\n\n        // \n        this.childrenSumHeight = this.outerHeight\n    }\n\n    computerSize() {\n        const ctx = this.ctx\n\n        ctx.font = \"14px Arial\";\n        const txt = this.ctx.measureText(this._context);\n        this.contextWidth = Math.max(txt.width, 40);\n        // @ts-ignore\n        this.contextHeight = txt.fontBoundingBoxAscent + txt.fontBoundingBoxDescent;\n        this.boxWidth = this.contextWidth + NodePadding * 2;\n        this.boxHeight = this.contextHeight + NodePadding * 2;\n        this.outerHeight = this.boxHeight + NodeMargin * 2\n        this.outerWidth = this.boxWidth + NodeMargin * 2\n    }\n\n    get context(): string {\n        return this._context\n    }\n    set context(value) {\n        this._context = value\n        this.computerSize()\n        this.bindTree?.shakeTree()\n        this.bindTree?.graph?.draw()\n    }\n\n    get state(): NodeState {\n        return this._state\n    }\n\n    set state(value) {\n        if (value === NodeState.Edit) {\n            this.bindTree.editoringNode = this\n        } else {\n            this.bindTree.editoringNode = null\n        }\n        this._state = value\n    }\n}\n\nclass NodeTree {\n    config: {\n        x: number,\n        y: number,\n        context?: string,\n        contextWidth?: number,\n        contextHeight?: number,\n    }\n\n    ctx: CanvasRenderingContext2D\n    tree: { [key: string]: NodeItem }\n    rootid: string\n    nodesRef: { [key: string]: NodeItem }\n    boardList: renderListWithItem\n    textList: renderListWithItem\n    linkList: renderListwithCoordinate\n    editoringNode: NodeItem\n    editor: Editor\n    graph: any\n\n    constructor(graph: any, config = { x: 0, y: 0, context: '', type: NodeType.Root }) {\n        this.graph = graph\n        const ctx = this.ctx = graph.ctx\n        const item = new NodeItem(ctx, { ...config, type: NodeType.Root });\n        this.rootid = item.id\n        this.tree = {}\n        this.tree[this.rootid] = item\n        this.nodesRef = this.nodesRef || {}\n        this.nodesRef[this.rootid] = item\n\n        // bind father\n        if (item.fatherId && this.tree[item.fatherId]) {\n            item.father = this.tree[item.fatherId]\n        }\n        item.bindTree = this\n\n        // bind editor and listen to the editor events\n        this.editor = editor\n        editor.onChange('new', ({ father, after }: { [key: string]: string }) => {\n            this.addNode({ context: 'New Node' }, father, after, true)\n            console.log('add node', father, after)\n        })\n\n    }\n\n    addNode(config = { context: '' }, fatherid?: string, afterid?: string, edit?: boolean) {\n\n        const fatherId = fatherid || this.rootid;\n        const fatherItem = this.nodesRef[fatherId];\n        const item = new NodeItem(this.ctx, {\n            ...config,\n            fatherId: fatherId\n        });\n\n        // add item to fater\n        const children = fatherItem.children = fatherItem.children || [];\n        // fatherItem.children = fatherItem.children || []\n\n        console.log('\\t', config, fatherid, afterid, edit)\n        // if we have afterid we have to put the new item after the id\n        // else we can add the new node to the end of the list\n        if (afterid) {\n            const index = children.findIndex(item => { return item.id === afterid });\n            if (index !== -1) {\n                children.splice(index + 1, 0, item)\n            } else {\n                return false;\n            }\n        } else {\n            children.push(item)\n        }\n\n        if (edit) {\n            this.graph.selected && (this.graph.selected.selected = false);\n            this.graph.selected = item;\n            item.selected = true\n            this.editoringNode = item\n        }\n\n        this.nodesRef[item.id] = item\n\n        // bind father\n        if (item.fatherId && this.tree[item.fatherId]) {\n            item.father = fatherItem\n        }\n        item.bindTree = this\n\n        // Re-computer position\n        // Height: update the height of all the affected nodes from parent to root\n        const onlyChildren = children.length <= 1\n        const increateHeight = onlyChildren ? 0 : item.outerHeight\n        let loopItem = item;\n        while (loopItem) {\n            const loopItemId = loopItem.fatherId\n            const fatherItem = this.nodesRef[loopItemId];\n            if (!loopItemId || !fatherItem) {\n                loopItem = null\n            } else {\n                fatherItem.childrenSumHeight += increateHeight\n                loopItem = fatherItem\n            }\n        }\n\n        // x,y\n        // A Node added may cause all the tree's layout change\n        // we need to restracture all the x,y for the tree.\n        this.shakeTree()\n\n        // \n        this.graph.draw()\n\n        console.log('new item id', item.id)\n\n        // \n        return item.id\n    }\n\n    // Reset all the node's position\n    shakeTree() {\n        interface drawInfo {\n            x: number\n            fatherY: number,\n            fatherX: number,\n            father?: NodeItem\n        }\n\n        const root = Object.keys(this.tree).map(id => this.nodesRef[id]);\n        const stacks: { info: drawInfo, items: NodeItem[] }[] = [{ info: { x: 0, fatherY: 0, fatherX: 0, }, items: root }];\n\n        const boardList: [NodeItem, { x: number, y: number }][] = [];\n        const textList: [NodeItem, { x: number, y: number }][] = [];\n        const linkList: [number, number, number, number][] = [];\n\n        let editingNode = null\n\n        while (stacks.length > 0) {\n            const stackItem = stacks.shift();\n\n            const info = stackItem.info;\n            const items = stackItem.items;\n\n            let listHgihtTrim = 0;\n            items.forEach((item, index) => {\n                listHgihtTrim += item.childrenSumHeight\n            })\n\n            const listStartY = info.fatherY - listHgihtTrim / 2\n\n            let nextSilbingStartY = listStartY\n            const onlyChildren = items.length === 1\n            items.forEach((item, index) => {\n                let itemY;\n                if (onlyChildren) {\n                    itemY = info.fatherY\n                } else {\n                    itemY = nextSilbingStartY + item.childrenSumHeight / 2\n                    nextSilbingStartY += item.childrenSumHeight\n                }\n                item.x = info.x\n                item.y = itemY\n\n                boardList.push([item, { x: info.x, y: itemY }])\n\n                textList.push([item, { x: info.x, y: itemY }])\n\n\n                if (info.father) {\n                    linkList.push([\n                        info.fatherX + info.father.boxWidth,\n                        info.fatherY,\n                        info.x,\n                        itemY\n                    ])\n                }\n\n                // \n                if (item.state === NodeState.Edit) {\n                    editingNode = item\n                }\n\n                const children = item.children;\n                if (children) {\n                    stacks.push({ info: { x: info.x + item.boxWidth + ListPadding, fatherY: itemY, fatherX: info.x, father: item }, items: children })\n                }\n            })\n        }\n\n        this.boardList = boardList;\n        this.textList = textList;\n        this.linkList = linkList;\n    }\n\n    // draw board box\n    drawBoard() {\n        const list = this.boardList\n        const ctx = this.ctx\n        const selecteNode: NodeItem[] = []\n        ctx.save()\n        const listByType: {\n            [key: string]: {\n                type: NodeType,\n                list: renderListwithCoordinate | renderListWithItem\n            }\n        } = {}\n\n        list.forEach(listItem => {\n            const [NodeItem] = listItem\n            if (NodeItem.selected) {\n                selecteNode.push(NodeItem)\n            }\n            listByType[NodeItem.type] = listByType[NodeItem.type] || {\n                type: NodeItem.type,\n                list: []\n            }\n            // @ts-ignore\n            listByType[NodeItem.type].list.push(listItem)\n        })\n\n        Object.keys(listByType).forEach(type => {\n            const list = listByType[type];\n            drawNode(list.type, this.ctx, list.list);\n        })\n        ctx.restore()\n\n        // draw selected\n        ctx.save()\n        selecteNode?.forEach(node => {\n            this.ctx.fillStyle = 'rgba(0,102,255,0.2)'\n            if (node.type === NodeType.Root) {\n                this.ctx.fillRect(node.x, node.y - node.boxHeight / 2, node.boxWidth, node.boxHeight)\n            } else {\n                this.ctx.fillRect(node.x, node.y - node.boxHeight, node.boxWidth, node.boxHeight)\n            }\n        })\n        ctx.restore()\n\n        // for debug\n        if (window.debug) {\n            list.forEach(board => {\n                const [item, offset] = board\n                const { x, y } = offset\n                // origin\n                ctx.save()\n                ctx.fillStyle = 'red'\n                ctx.translate(x, y)\n                ctx.fillRect(-2, -2, 4, 4)\n                ctx.restore()\n                // group\n                ctx.save()\n                ctx.fillStyle = 'red'\n                ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n                this.ctx.strokeStyle = 'red'\n                ctx.strokeRect(-NodePadding, -item.childrenSumHeight / 2, item.boxWidth, item.childrenSumHeight)\n                ctx.restore()\n\n                // context\n                ctx.save()\n                ctx.translate(x, y)\n                ctx.translate(NodePadding, -item.boxHeight / 2)\n                ctx.strokeRect(0, -item.contextHeight / 2, item.contextWidth, item.contextHeight)\n                ctx.restore()\n                // outer\n                ctx.save()\n                ctx.strokeStyle = 'grey'\n                ctx.translate(x, y)\n                ctx.translate(-NodePadding, -item.boxHeight - NodeMargin)\n                ctx.strokeRect(0, 0, item.outerWidth, item.outerHeight)\n                ctx.restore()\n                // box\n                ctx.save()\n                ctx.strokeStyle = 'yellow'\n                ctx.translate(x, y)\n                ctx.translate(0, -item.boxHeight)\n                ctx.strokeRect(0, 0, item.boxWidth, item.boxHeight)\n                ctx.restore()\n\n\n                // Tips text\n                ctx.save()\n                ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n                this.ctx.fillStyle = 'red'\n                ctx.font = \"10px Arial\";\n                ctx.fillText((item.childrenSumHeight).toFixed(2).toString(), item.boxWidth, NodePadding * 2 - item.boxHeight)\n                ctx.fillText((item.outerHeight).toFixed(2).toString(), item.boxWidth, NodePadding * 2 - item.boxHeight + 10)\n                ctx.fillText(`${(item.x).toFixed(0).toString()},${(item.y || 0).toFixed(0).toString()} `, item.boxWidth, NodePadding * 2 - item.boxHeight + 20)\n                ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n                ctx.restore()\n\n            })\n\n        }\n    }\n\n    drawText() {\n        const list = this.textList\n        const ctx = this.ctx\n        ctx.save()\n        ctx.textAlign = 'left'\n        ctx.textBaseline = 'middle'\n\n        list.forEach(board => {\n            const [item, offset] = board\n            if (item === this.editoringNode) return false\n            let { x, y } = offset\n            if (item.type === NodeType.Root) {\n                y = y + item.boxHeight / 2\n            }\n            ctx.translate(x + NodePadding, y - item.boxHeight / 2)\n            const { context, boxHeight, boxWidth, outerHeight } = item\n            ctx.font = \"14px Arial\";\n            ctx.fillText(context, 0, 0)\n            ctx.translate(-(x + NodePadding), -(y - item.boxHeight / 2))\n        })\n        ctx.restore()\n    }\n\n    drawLink() {\n        const list = this.linkList\n        const ctx = this.ctx\n        ctx.save()\n        ctx.strokeStyle = '#e99b47';\n        ctx.beginPath()\n        list.forEach(board => {\n\n            //                                    (endX, endY)\n            //                              ---------- B\n            //                             |\n            //          A --------(middleX, startY)\n            //  (startX, startY)           |\n            //                              ---------- C\n            //                                    (endX, endY)\n\n            const [startX, startY, endX, endY] = board;\n            const deltaY = Math.abs(endY - startY);\n            const radius = 6;\n            const middleX = (startX + endX) / 2;\n            const endLowerThanStart = endY < startY;\n\n            ctx.moveTo(startX, startY);\n            ctx.lineTo(middleX - radius, startY);\n            // inflection\n            if (deltaY / 2 >= radius) {\n                ctx.quadraticCurveTo(middleX, startY, middleX, startY + (endLowerThanStart ? -radius : radius))\n                ctx.lineTo(middleX, endY + (endLowerThanStart ? radius : -radius));\n                ctx.quadraticCurveTo(middleX, endY, middleX + radius, endY)\n            } else {\n                ctx.bezierCurveTo(middleX, startY, middleX, endY, middleX + radius, endY)\n            }\n            // \n            ctx.lineTo(endX, endY)\n        })\n        ctx.stroke()\n        ctx.closePath()\n    }\n\n    updateEditor() {\n        const node = this.editoringNode;\n        const dpr = window.devicePixelRatio || 1\n        if (!node) {\n            editor.hide()\n            return;\n        }\n        // TODO: Show the editor \n        const { a: ctxScale, e: ctxOffsetX, f: ctxOffsetY } = this.ctx.getTransform()\n\n        const { x: nodeX, y: nodeY, contextWidth, contextHeight } = node\n\n        const [screenOrignX, screenOrginY] = [(ctxOffsetX + nodeX * ctxScale) / dpr, (ctxOffsetY + nodeY * ctxScale) / dpr]\n\n        let offsetX = 0;\n        let offsetY = 0;\n        if (node.type === NodeType.Node) {\n            offsetX = NodePadding * (ctxScale / dpr)\n            offsetY -= NodePadding * (ctxScale / dpr)\n        } else if (node.type === NodeType.Root) {\n            offsetX = NodePadding * (ctxScale / dpr)\n            offsetY += (NodePadding - 2) * (ctxScale / dpr)\n        }\n\n\n        editor.show(screenOrignX + offsetX, screenOrginY + offsetY, contextWidth, contextHeight, ctxScale, node)\n\n    }\n\n    draw() {\n        // draw components step by step\n        this.drawBoard()\n        this.drawText()\n        this.drawLink()\n        this.updateEditor()\n    }\n}\n\n\nexport { NodeItem, NodeTree }","// This file is to create the init Canvas document and set up the resolution and other stuffs.\n// @ts-nocheck\n\nimport { NodeItem, NodeTree } from './nodes'\nimport { NodeType, NodeState } from './cavnas-node-types'\n\ninterface size {\n    width: number,\n    height: number\n}\n\nclass CoreCanvas {\n    canvas: HTMLCanvasElement\n    ctx: CanvasRenderingContext2D\n    offset: {\n        x: number,\n        y: number,\n    }\n    events: any\n    scale: number\n    nodeTrees: NodeItem[]\n    hover: NodeItem\n    selected: NodeItem\n    editItem: NodeItem\n    size: size\n    dpr: number\n\n    constructor(size: size) {\n        this.dpr = window.devicePixelRatio || 1\n        this.scale = this.dpr;\n        this.size = size\n        this.offset = { x: size.width / 2 * this.scale, y: size.height / 2 * this.scale }\n        this.events = {}\n\n        const canvas = this.canvas = document.createElement('canvas')\n        this.ctx = canvas.getContext('2d')\n        window.ctx = this.ctx\n\n        this.adjustCanvs(canvas, size);\n        this.bindEvent()\n\n        // TEST\n        // addNode\n        const testNode = window.testNode = new NodeTree(this, {\n            x: 0,\n            y: 0,\n            context: 'Hello'\n        })\n\n        let tid = 0;\n        tid = testNode.addNode({\n            context: 'Robin Ma'\n        })\n\n\n        tid = testNode.addNode({\n            context: 'CKY'\n        })\n        testNode.addNode({\n            context: 'Name: kaiyue'\n        }, tid)\n        tid = testNode.addNode({\n            context: 'Mofei Zhu'\n        })\n\n        testNode.addNode({\n            context: 'Name: Mofei'\n        }, tid)\n        testNode.addNode({\n            context: 'Sex: Fame'\n        }, tid)\n\n        tid = testNode.addNode({\n            context: 'Age: 18'\n        }, tid)\n        console.log('add after', tid)\n        testNode.addNode({\n            context: '1'\n        }, tid)\n\n\n        tid = testNode.addNode({\n            context: 'Mll'\n        })\n\n        const selected = testNode.nodesRef[tid];\n        // selected.state = NodeState.Edit\n\n\n        tid = testNode.addNode({\n            context: 'Ml2'\n        })\n\n\n        // for (let i = 0; i < 5; i++) {\n        //     tid = testNode.addNode({\n        //         context: i\n        //     }, tid)\n        // }\n        this.nodeTrees = [testNode]\n    }\n\n    adjustCanvs(canvas: HTMLCanvasElement, size: size) {\n        // Get the device pixel ratio, falling back to 1.\n\n        // Give the canvas pixel dimensions of their CSS\n        // size * the device pixel ratio.\n        canvas.style.width = `${size.width}px`;\n        canvas.style.height = `${size.height}px`;\n        canvas.width = size.width * this.dpr;\n        canvas.height = size.height * this.dpr;\n        this.ctx.translate(this.offset.x, this.offset.y)\n        this.ctx.scale(this.dpr, this.dpr)\n    }\n\n    // The events Config the canvas by translate and scale, so that NodeItems don't need to care about the translate and scale\n    bindEvent() {\n        const canvas = this.canvas;\n        let moving = 'DONE';\n        let mousedownX = null;\n        let mousedownY = null;\n        let lastX = null;\n        let lastY = null;\n\n        canvas.addEventListener('mousedown', (e) => {\n            moving = 'PREPARE';\n            lastX = mousedownX = e.offsetX\n            lastY = mousedownY = e.offsetY\n\n            if (this.editItem) {\n                // Clean the Editor model\n                this.editItem?.state = NodeState.Default\n                this.editItem = null\n                this.draw()\n            }\n        });\n\n        canvas.addEventListener('mousemove', (e) => {\n            if (moving === 'PREPARE' || moving === 'MOVING') {\n                // Moving modle\n                // In moving modle we translate the canvas, \n                //   so that in the node tree draw step, \n                //   the nodes don't need to consider the canvas translate.\n                const { dpr, scale, offset } = this\n                const moveDelteX = e.offsetX - lastX;\n                const moveDelteY = e.offsetY - lastY;\n                const scaleRatio = (scale / dpr);\n                lastY = e.offsetY\n                lastX = e.offsetX\n                moving = 'MOVING'\n\n                this.ctx.translate(moveDelteX / scaleRatio, moveDelteY / scaleRatio)\n\n                this.draw()\n            } else {\n                // Free move modle\n                // In free modle, we calculate the mouse's relation with the nodes,\n                //   and save the hovered node to this.hover\n                const onCanvasX = (e.offsetX * this.dpr - this.offset.x) / this.scale\n                const onCanvasY = (e.offsetY * this.dpr - this.offset.y) / this.scale\n\n                let matchedNode = null;\n                // Loop the tree's position\n                this.nodeTrees.forEach(({ tree }) => {\n                    const stack = [Object.keys(tree).map(roodId => tree[roodId])];\n                    while (stack.length >= 1) {\n                        const nodes = stack.pop();\n\n                        for (let node of nodes) {\n                            const nodeXRange = Math.max(Math.abs(node.x), 0)\n\n                            const xInBoundary = nodeXRange < Math.abs(onCanvasX);\n                            const yInBoundary = Math.abs(node.y || 0) < (Math.abs(onCanvasY) + node.outerHeight);\n                            const nodeChildren = node.children\n                            if (xInBoundary && yInBoundary) {\n                                // math Node\n                                //  -----------------         -----------------\n                                // |                 |       |                 |\n                                // .(x,y) ROOOT      |       |    Others       |\n                                // |                 |       |                 |\n                                //  -----------------        .(x,y)------------\n                                // If the node type is root the origin is in the left-middle\n                                // Other whise the origin is in the left-bottom\n                                const XinBox = onCanvasX >= node.x && onCanvasX <= node.x + node.boxWidth\n                                let YOffset = node.type === NodeType.Root ? node.boxHeight / 2 : 0\n                                const YinBox = onCanvasY >= (node.y - node.boxHeight + YOffset) && onCanvasY <= (node.y + YOffset)\n                                if (XinBox && YinBox) {\n                                    matchedNode = node\n                                    stack.length = 0\n                                    break\n                                }\n\n                                if (nodeChildren) {\n                                    stack.push(nodeChildren)\n                                }\n                            }\n                        }\n                    }\n                })\n\n                if (matchedNode) {\n                    this.canvas.style.cursor = 'pointer'\n                } else {\n                    this.canvas.style.cursor = 'default'\n                }\n\n                this.hover = matchedNode\n            }\n        });\n\n        canvas.addEventListener('mouseup', (e) => {\n            e.preventDefault()\n            moving = 'DONE'\n            lastX = lastY = null\n            const newTransform = this.ctx.getTransform()\n            this.scale = newTransform.a\n            this.offset = {\n                x: newTransform.e,\n                y: newTransform.f\n            }\n        });\n\n        canvas.addEventListener('wheel', (e) => {\n            const { dpr, scale, offset } = this\n            e.preventDefault();\n\n            const scaleDelta = Math.pow(1.01, -e.deltaY);\n            const scaleRatio = (scale / dpr);\n\n            ctx.setTransform(scale, 0, 0, scale, offset.x, offset.y)\n            this.ctx.translate(-offset.x / scale + e.offsetX / scaleRatio, -offset.y / scale + e.offsetY / scaleRatio)\n            this.ctx.scale(scaleDelta, scaleDelta)\n            this.ctx.translate(-(-offset.x / scale + e.offsetX / scaleRatio), -(-offset.y / scale + e.offsetY / scaleRatio))\n\n            const newTransform = this.ctx.getTransform()\n            this.scale = newTransform.a\n            this.offset = {\n                x: newTransform.e,\n                y: newTransform.f\n            }\n\n            this.draw()\n        });\n\n        canvas.addEventListener('click', (e) => {\n            // Prevent trigger the click event while you movingthe canvas\n            if (Math.abs(e.offsetX - mousedownX) > 5 || Math.abs(e.offsetY - mousedownY) > 5) return false;\n\n\n            // If you click the Node twice the node will become the Editor mode\n            // Otherwise the Node will exit the Editor mode\n            if (this.hover && this.selected === this.hover) {\n                this.hover.state = NodeState.Edit\n                this.editItem = this.hover\n            } else if (this.hover !== this.editItem) {\n                this.editItem?.state = NodeState.Default\n                this.editItem = null\n            }\n\n            // Re assign the select Node\n            this.selected?.selected = false\n            this.selected = this.hover;\n            this.selected?.selected = true;\n\n\n            this.draw();\n        })\n    }\n\n    // Draw Nodetree\n    // 1. Clean the canvas\n    // 2. Call the draw function from the Node tree\n    draw() {\n        const ctx = this.ctx;\n        // Reset the canvas and clean it\n        ctx.save()\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n        ctx.fillStyle = '#f3f3f4'\n        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)\n        ctx.restore();\n\n\n        // \n        if (window.debug) {\n            // origin \n            this.ctx.save()\n            this.ctx.beginPath()\n            this.ctx.strokeStyle = 'red'\n            this.ctx.lineWidth = 2\n            this.ctx.moveTo(0, -5)\n            this.ctx.lineTo(0, 5)\n            this.ctx.moveTo(-5, 0)\n            this.ctx.lineTo(5, 0)\n            this.ctx.stroke()\n            this.ctx.closePath()\n\n            // gird\n            this.ctx.beginPath()\n            this.ctx.strokeStyle = '#ddd'\n            const xCount = Math.round(this.size.width / 10)\n            for (let i = -xCount; i < xCount; i += 1) {\n                this.ctx.moveTo(i * -10, -this.size.height)\n                this.ctx.lineTo(i * -10, this.size.height)\n            }\n            const yCount = Math.round(this.size.height / 10)\n            for (let i = -yCount; i < yCount; i += 1) {\n                this.ctx.moveTo(-this.size.width, i * -10)\n                this.ctx.lineTo(this.size.width, i * -10)\n            }\n            this.ctx.closePath()\n            this.ctx.stroke()\n\n            this.ctx.restore()\n        }\n\n        // Draw the node tree\n        const nodeTrees = this.nodeTrees || [];\n        nodeTrees.forEach(item => {\n            item.draw()\n        });\n\n    }\n}\n\n// Canvas garph\nclass CanvasGraph {\n    coreCanvas: CoreCanvas\n    canvas: HTMLCanvasElement\n    ctx: CanvasRenderingContext2D\n    needUpdate: boolean\n    constructor(dom: HTMLElement) {\n        const styleInfo = getComputedStyle(dom)\n        const size = {\n            width: parseFloat(styleInfo.width),\n            height: parseFloat(styleInfo.height)\n        }\n        this.coreCanvas = new CoreCanvas(size);\n\n        this.canvas = this.coreCanvas.canvas\n        this.ctx = this.coreCanvas.ctx\n\n        this.coreCanvas.draw()\n    }\n\n}\n\nexport { CanvasGraph }","import { AthenaMindmap } from '../athena-mindmap';\n\nnew AthenaMindmap('container')","import * as graph from './graph/canvas'\n\n// window.debug = true;\n\n/**\n * @class\n * @param {string} container the dom id where we put the mindmap\n */\nclass AthenaMindmap {\n    container: HTMLElement\n    graph: graph.CanvasGraph\n    ctx: CanvasRenderingContext2D\n    constructor(container: string, config?: object) {\n        this.container = document.getElementById(container);\n        this.graph = new graph.CanvasGraph(this.container);\n        // \n        console.log('Hello Athena!')\n        this.container.appendChild(this.graph.canvas)\n    }\n}\n\nexport { AthenaMindmap }"],"sourceRoot":""}